"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/media-query-parser";
exports.ids = ["vendor-chunks/media-query-parser"];
exports.modules = {

/***/ "(ssr)/./node_modules/media-query-parser/dist/media-query-parser.esm.js":
/*!************************************************************************!*\
  !*** ./node_modules/media-query-parser/dist/media-query-parser.esm.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   consumeEscape: () => (/* binding */ consumeEscape),\n/* harmony export */   consumeIdent: () => (/* binding */ consumeIdent),\n/* harmony export */   consumeIdentLike: () => (/* binding */ consumeIdentLike),\n/* harmony export */   consumeIdentUnsafe: () => (/* binding */ consumeIdentUnsafe),\n/* harmony export */   consumeNumber: () => (/* binding */ consumeNumber),\n/* harmony export */   consumeNumeric: () => (/* binding */ consumeNumeric),\n/* harmony export */   consumeString: () => (/* binding */ consumeString),\n/* harmony export */   consumeUrl: () => (/* binding */ consumeUrl),\n/* harmony export */   lexicalAnalysis: () => (/* binding */ lexicalAnalysis),\n/* harmony export */   removeWhitespace: () => (/* binding */ removeWhitespace),\n/* harmony export */   syntacticAnalysis: () => (/* binding */ syntacticAnalysis),\n/* harmony export */   toAST: () => (/* binding */ toAST),\n/* harmony export */   toUnflattenedAST: () => (/* binding */ toUnflattenedAST),\n/* harmony export */   tokenizeMediaCondition: () => (/* binding */ tokenizeMediaCondition),\n/* harmony export */   tokenizeMediaFeature: () => (/* binding */ tokenizeMediaFeature),\n/* harmony export */   tokenizeMediaQuery: () => (/* binding */ tokenizeMediaQuery),\n/* harmony export */   tokenizeRange: () => (/* binding */ tokenizeRange),\n/* harmony export */   wouldStartIdentifier: () => (/* binding */ wouldStartIdentifier)\n/* harmony export */ });\n/*! @license MediaQueryParser - MIT License - Tom Golden (github@tbjgolden.com) */\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\n\nvar weirdNewlines = /(\\u000D|\\u000C|\\u000D\\u000A)/g;\nvar nullOrSurrogates = /[\\u0000\\uD800-\\uDFFF]/g;\nvar commentRegex = /(\\/\\*)[\\s\\S]*?(\\*\\/)/g;\nvar lexicalAnalysis = function lexicalAnalysis(str, index) {\n  if (index === void 0) {\n    index = 0;\n  }\n\n  str = str.replace(weirdNewlines, '\\n').replace(nullOrSurrogates, \"\\uFFFD\");\n  str = str.replace(commentRegex, '');\n  var tokens = [];\n\n  for (; index < str.length; index += 1) {\n    var code = str.charCodeAt(index);\n\n    if (code === 0x0009 || code === 0x0020 || code === 0x000a) {\n      var code_1 = str.charCodeAt(++index);\n\n      while (code_1 === 0x0009 || code_1 === 0x0020 || code_1 === 0x000a) {\n        code_1 = str.charCodeAt(++index);\n      }\n\n      index -= 1;\n      tokens.push({\n        type: '<whitespace-token>'\n      });\n    } else if (code === 0x0022) {\n      var result = consumeString(str, index);\n\n      if (result === null) {\n        return null;\n      }\n\n      var _a = __read(result, 2),\n          lastIndex = _a[0],\n          value = _a[1];\n\n      tokens.push({\n        type: '<string-token>',\n        value: value\n      });\n      index = lastIndex;\n    } else if (code === 0x0023) {\n      if (index + 1 < str.length) {\n        var nextCode = str.charCodeAt(index + 1);\n\n        if (nextCode === 0x005f || nextCode >= 0x0041 && nextCode <= 0x005a || nextCode >= 0x0061 && nextCode <= 0x007a || nextCode >= 0x0080 || nextCode >= 0x0030 && nextCode <= 0x0039 || nextCode === 0x005c && index + 2 < str.length && str.charCodeAt(index + 2) !== 0x000a) {\n          var flag = wouldStartIdentifier(str, index + 1) ? 'id' : 'unrestricted';\n          var result = consumeIdentUnsafe(str, index + 1);\n\n          if (result !== null) {\n            var _b = __read(result, 2),\n                lastIndex = _b[0],\n                value = _b[1];\n\n            tokens.push({\n              type: '<hash-token>',\n              value: value.toLowerCase(),\n              flag: flag\n            });\n            index = lastIndex;\n            continue;\n          }\n        }\n      }\n\n      tokens.push({\n        type: '<delim-token>',\n        value: code\n      });\n    } else if (code === 0x0027) {\n      var result = consumeString(str, index);\n\n      if (result === null) {\n        return null;\n      }\n\n      var _c = __read(result, 2),\n          lastIndex = _c[0],\n          value = _c[1];\n\n      tokens.push({\n        type: '<string-token>',\n        value: value\n      });\n      index = lastIndex;\n    } else if (code === 0x0028) {\n      tokens.push({\n        type: '<(-token>'\n      });\n    } else if (code === 0x0029) {\n      tokens.push({\n        type: '<)-token>'\n      });\n    } else if (code === 0x002b) {\n      var plusNumeric = consumeNumeric(str, index);\n\n      if (plusNumeric === null) {\n        tokens.push({\n          type: '<delim-token>',\n          value: code\n        });\n      } else {\n        var _d = __read(plusNumeric, 2),\n            lastIndex = _d[0],\n            tokenTuple = _d[1];\n\n        if (tokenTuple[0] === '<dimension-token>') {\n          tokens.push({\n            type: '<dimension-token>',\n            value: tokenTuple[1],\n            unit: tokenTuple[2].toLowerCase(),\n            flag: 'number'\n          });\n        } else if (tokenTuple[0] === '<number-token>') {\n          tokens.push({\n            type: tokenTuple[0],\n            value: tokenTuple[1],\n            flag: tokenTuple[2]\n          });\n        } else {\n          tokens.push({\n            type: tokenTuple[0],\n            value: tokenTuple[1],\n            flag: 'number'\n          });\n        }\n\n        index = lastIndex;\n      }\n    } else if (code === 0x002c) {\n      tokens.push({\n        type: '<comma-token>'\n      });\n    } else if (code === 0x002d) {\n      var minusNumeric = consumeNumeric(str, index);\n\n      if (minusNumeric !== null) {\n        var _e = __read(minusNumeric, 2),\n            lastIndex = _e[0],\n            tokenTuple = _e[1];\n\n        if (tokenTuple[0] === '<dimension-token>') {\n          tokens.push({\n            type: '<dimension-token>',\n            value: tokenTuple[1],\n            unit: tokenTuple[2].toLowerCase(),\n            flag: 'number'\n          });\n        } else if (tokenTuple[0] === '<number-token>') {\n          tokens.push({\n            type: tokenTuple[0],\n            value: tokenTuple[1],\n            flag: tokenTuple[2]\n          });\n        } else {\n          tokens.push({\n            type: tokenTuple[0],\n            value: tokenTuple[1],\n            flag: 'number'\n          });\n        }\n\n        index = lastIndex;\n        continue;\n      }\n\n      if (index + 2 < str.length) {\n        var nextCode = str.charCodeAt(index + 1);\n        var nextNextCode = str.charCodeAt(index + 2);\n\n        if (nextCode === 0x002d && nextNextCode === 0x003e) {\n          tokens.push({\n            type: '<CDC-token>'\n          });\n          index += 2;\n          continue;\n        }\n      }\n\n      var result = consumeIdentLike(str, index);\n\n      if (result !== null) {\n        var _f = __read(result, 3),\n            lastIndex = _f[0],\n            value = _f[1],\n            type = _f[2];\n\n        tokens.push({\n          type: type,\n          value: value\n        });\n        index = lastIndex;\n        continue;\n      }\n\n      tokens.push({\n        type: '<delim-token>',\n        value: code\n      });\n    } else if (code === 0x002e) {\n      var minusNumeric = consumeNumeric(str, index);\n\n      if (minusNumeric === null) {\n        tokens.push({\n          type: '<delim-token>',\n          value: code\n        });\n      } else {\n        var _g = __read(minusNumeric, 2),\n            lastIndex = _g[0],\n            tokenTuple = _g[1];\n\n        if (tokenTuple[0] === '<dimension-token>') {\n          tokens.push({\n            type: '<dimension-token>',\n            value: tokenTuple[1],\n            unit: tokenTuple[2].toLowerCase(),\n            flag: 'number'\n          });\n        } else if (tokenTuple[0] === '<number-token>') {\n          tokens.push({\n            type: tokenTuple[0],\n            value: tokenTuple[1],\n            flag: tokenTuple[2]\n          });\n        } else {\n          tokens.push({\n            type: tokenTuple[0],\n            value: tokenTuple[1],\n            flag: 'number'\n          });\n        }\n\n        index = lastIndex;\n        continue;\n      }\n    } else if (code === 0x003a) {\n      tokens.push({\n        type: '<colon-token>'\n      });\n    } else if (code === 0x003b) {\n      tokens.push({\n        type: '<semicolon-token>'\n      });\n    } else if (code === 0x003c) {\n      if (index + 3 < str.length) {\n        var nextCode = str.charCodeAt(index + 1);\n        var nextNextCode = str.charCodeAt(index + 2);\n        var nextNextNextCode = str.charCodeAt(index + 3);\n\n        if (nextCode === 0x0021 && nextNextCode === 0x002d && nextNextNextCode === 0x002d) {\n          tokens.push({\n            type: '<CDO-token>'\n          });\n          index += 3;\n          continue;\n        }\n      }\n\n      tokens.push({\n        type: '<delim-token>',\n        value: code\n      });\n    } else if (code === 0x0040) {\n      var result = consumeIdent(str, index + 1);\n\n      if (result !== null) {\n        var _h = __read(result, 2),\n            lastIndex = _h[0],\n            value = _h[1];\n\n        tokens.push({\n          type: '<at-keyword-token>',\n          value: value.toLowerCase()\n        });\n        index = lastIndex;\n        continue;\n      }\n\n      tokens.push({\n        type: '<delim-token>',\n        value: code\n      });\n    } else if (code === 0x005b) {\n      tokens.push({\n        type: '<[-token>'\n      });\n    } else if (code === 0x005c) {\n      var result = consumeEscape(str, index);\n\n      if (result === null) {\n        return null;\n      }\n\n      var _j = __read(result, 2),\n          lastIndex = _j[0],\n          value = _j[1];\n\n      str = str.slice(0, index) + value + str.slice(lastIndex + 1);\n      index -= 1;\n    } else if (code === 0x005d) {\n      tokens.push({\n        type: '<]-token>'\n      });\n    } else if (code === 0x007b) {\n      tokens.push({\n        type: '<{-token>'\n      });\n    } else if (code === 0x007d) {\n      tokens.push({\n        type: '<}-token>'\n      });\n    } else if (code >= 0x0030 && code <= 0x0039) {\n      var result = consumeNumeric(str, index);\n\n      var _k = __read(result, 2),\n          lastIndex = _k[0],\n          tokenTuple = _k[1];\n\n      if (tokenTuple[0] === '<dimension-token>') {\n        tokens.push({\n          type: '<dimension-token>',\n          value: tokenTuple[1],\n          unit: tokenTuple[2].toLowerCase(),\n          flag: 'number'\n        });\n      } else if (tokenTuple[0] === '<number-token>') {\n        tokens.push({\n          type: tokenTuple[0],\n          value: tokenTuple[1],\n          flag: tokenTuple[2]\n        });\n      } else {\n        tokens.push({\n          type: tokenTuple[0],\n          value: tokenTuple[1],\n          flag: 'number'\n        });\n      }\n\n      index = lastIndex;\n    } else if (code === 0x005f || code >= 0x0041 && code <= 0x005a || code >= 0x0061 && code <= 0x007a || code >= 0x0080) {\n      var result = consumeIdentLike(str, index);\n\n      if (result === null) {\n        return null;\n      }\n\n      var _l = __read(result, 3),\n          lastIndex = _l[0],\n          value = _l[1],\n          type = _l[2];\n\n      tokens.push({\n        type: type,\n        value: value\n      });\n      index = lastIndex;\n    } else {\n      tokens.push({\n        type: '<delim-token>',\n        value: code\n      });\n    }\n  }\n\n  tokens.push({\n    type: '<EOF-token>'\n  });\n  return tokens;\n};\nvar consumeString = function consumeString(str, index) {\n  if (str.length <= index + 1) return null;\n  var firstCode = str.charCodeAt(index);\n  var charCodes = [];\n\n  for (var i = index + 1; i < str.length; i += 1) {\n    var code = str.charCodeAt(i);\n\n    if (code === firstCode) {\n      return [i, String.fromCharCode.apply(null, charCodes)];\n    } else if (code === 0x005c) {\n      var result = consumeEscape(str, i);\n      if (result === null) return null;\n\n      var _a = __read(result, 2),\n          lastIndex = _a[0],\n          charCode = _a[1];\n\n      charCodes.push(charCode);\n      i = lastIndex;\n    } else if (code === 0x000a) {\n      return null;\n    } else {\n      charCodes.push(code);\n    }\n  }\n\n  return null;\n};\nvar wouldStartIdentifier = function wouldStartIdentifier(str, index) {\n  if (str.length <= index) return false;\n  var code = str.charCodeAt(index);\n\n  if (code === 0x002d) {\n    if (str.length <= index + 1) return false;\n    var nextCode = str.charCodeAt(index + 1);\n\n    if (nextCode === 0x002d || nextCode === 0x005f || nextCode >= 0x0041 && nextCode <= 0x005a || nextCode >= 0x0061 && nextCode <= 0x007a || nextCode >= 0x0080) {\n      return true;\n    } else if (nextCode === 0x005c) {\n      if (str.length <= index + 2) return false;\n      var nextNextCode = str.charCodeAt(index + 2);\n      return nextNextCode !== 0x000a;\n    } else {\n      return false;\n    }\n  } else if (code === 0x005f || code >= 0x0041 && code <= 0x005a || code >= 0x0061 && code <= 0x007a || code >= 0x0080) {\n    return true;\n  } else if (code === 0x005c) {\n    if (str.length <= index + 1) return false;\n    var nextCode = str.charCodeAt(index + 1);\n    return nextCode !== 0x000a;\n  } else {\n    return false;\n  }\n};\nvar consumeEscape = function consumeEscape(str, index) {\n  if (str.length <= index + 1) return null;\n  if (str.charCodeAt(index) !== 0x005c) return null;\n  var code = str.charCodeAt(index + 1);\n\n  if (code === 0x000a) {\n    return null;\n  } else if (code >= 0x0030 && code <= 0x0039 || code >= 0x0041 && code <= 0x0046 || code >= 0x0061 && code <= 0x0066) {\n    var hexCharCodes = [code];\n    var min = Math.min(index + 7, str.length);\n    var i = index + 2;\n\n    for (; i < min; i += 1) {\n      var code_2 = str.charCodeAt(i);\n\n      if (code_2 >= 0x0030 && code_2 <= 0x0039 || code_2 >= 0x0041 && code_2 <= 0x0046 || code_2 >= 0x0061 && code_2 <= 0x0066) {\n        hexCharCodes.push(code_2);\n      } else {\n        break;\n      }\n    }\n\n    if (i < str.length) {\n      var code_3 = str.charCodeAt(i);\n\n      if (code_3 === 0x0009 || code_3 === 0x0020 || code_3 === 0x000a) {\n        i += 1;\n      }\n    }\n\n    return [i - 1, parseInt(String.fromCharCode.apply(null, hexCharCodes), 16)];\n  } else {\n    return [index + 1, code];\n  }\n};\nvar consumeNumeric = function consumeNumeric(str, index) {\n  var numberResult = consumeNumber(str, index);\n  if (numberResult === null) return null;\n\n  var _a = __read(numberResult, 3),\n      numberEndIndex = _a[0],\n      numberValue = _a[1],\n      numberFlag = _a[2];\n\n  var identResult = consumeIdent(str, numberEndIndex + 1);\n\n  if (identResult !== null) {\n    var _b = __read(identResult, 2),\n        identEndIndex = _b[0],\n        identValue = _b[1];\n\n    return [identEndIndex, ['<dimension-token>', numberValue, identValue]];\n  }\n\n  if (numberEndIndex + 1 < str.length && str.charCodeAt(numberEndIndex + 1) === 0x0025) {\n    return [numberEndIndex + 1, ['<percentage-token>', numberValue]];\n  }\n\n  return [numberEndIndex, ['<number-token>', numberValue, numberFlag]];\n};\nvar consumeNumber = function consumeNumber(str, index) {\n  if (str.length <= index) return null;\n  var flag = 'integer';\n  var numberChars = [];\n  var firstCode = str.charCodeAt(index);\n\n  if (firstCode === 0x002b || firstCode === 0x002d) {\n    index += 1;\n    if (firstCode === 0x002d) numberChars.push(0x002d);\n  }\n\n  while (index < str.length) {\n    var code = str.charCodeAt(index);\n\n    if (code >= 0x0030 && code <= 0x0039) {\n      numberChars.push(code);\n      index += 1;\n    } else {\n      break;\n    }\n  }\n\n  if (index + 1 < str.length) {\n    var nextCode = str.charCodeAt(index);\n    var nextNextCode = str.charCodeAt(index + 1);\n\n    if (nextCode === 0x002e && nextNextCode >= 0x0030 && nextNextCode <= 0x0039) {\n      numberChars.push(nextCode, nextNextCode);\n      flag = 'number';\n      index += 2;\n\n      while (index < str.length) {\n        var code = str.charCodeAt(index);\n\n        if (code >= 0x0030 && code <= 0x0039) {\n          numberChars.push(code);\n          index += 1;\n        } else {\n          break;\n        }\n      }\n    }\n  }\n\n  if (index + 1 < str.length) {\n    var nextCode = str.charCodeAt(index);\n    var nextNextCode = str.charCodeAt(index + 1);\n    var nextNextNextCode = str.charCodeAt(index + 2);\n\n    if (nextCode === 0x0045 || nextCode === 0x0065) {\n      var nextNextIsDigit = nextNextCode >= 0x0030 && nextNextCode <= 0x0039;\n\n      if (nextNextIsDigit || (nextNextCode === 0x002b || nextNextCode === 0x002d) && nextNextNextCode >= 0x0030 && nextNextNextCode <= 0x0039) {\n        flag = 'number';\n\n        if (nextNextIsDigit) {\n          numberChars.push(0x0045, nextNextCode);\n          index += 2;\n        } else if (nextNextCode === 0x002d) {\n          numberChars.push(0x0045, 0x002d, nextNextNextCode);\n          index += 3;\n        } else {\n          numberChars.push(0x0045, nextNextNextCode);\n          index += 3;\n        }\n\n        while (index < str.length) {\n          var code = str.charCodeAt(index);\n\n          if (code >= 0x0030 && code <= 0x0039) {\n            numberChars.push(code);\n            index += 1;\n          } else {\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  var numberString = String.fromCharCode.apply(null, numberChars);\n  var value = flag === 'number' ? parseFloat(numberString) : parseInt(numberString);\n  if (value === -0) value = 0;\n  return Number.isNaN(value) ? null : [index - 1, value, flag];\n};\nvar consumeIdentUnsafe = function consumeIdentUnsafe(str, index) {\n  if (str.length <= index) {\n    return null;\n  }\n\n  var identChars = [];\n\n  for (var code = str.charCodeAt(index); index < str.length; code = str.charCodeAt(++index)) {\n    if (code === 0x002d || code === 0x005f || code >= 0x0041 && code <= 0x005a || code >= 0x0061 && code <= 0x007a || code >= 0x0080 || code >= 0x0030 && code <= 0x0039) {\n      identChars.push(code);\n      continue;\n    } else {\n      var result = consumeEscape(str, index);\n\n      if (result !== null) {\n        var _a = __read(result, 2),\n            lastIndex = _a[0],\n            code_4 = _a[1];\n\n        identChars.push(code_4);\n        index = lastIndex;\n        continue;\n      }\n    }\n\n    break;\n  }\n\n  return index === 0 ? null : [index - 1, String.fromCharCode.apply(null, identChars)];\n};\nvar consumeIdent = function consumeIdent(str, index) {\n  if (str.length <= index || !wouldStartIdentifier(str, index)) {\n    return null;\n  }\n\n  var identChars = [];\n\n  for (var code = str.charCodeAt(index); index < str.length; code = str.charCodeAt(++index)) {\n    if (code === 0x002d || code === 0x005f || code >= 0x0041 && code <= 0x005a || code >= 0x0061 && code <= 0x007a || code >= 0x0080 || code >= 0x0030 && code <= 0x0039) {\n      identChars.push(code);\n      continue;\n    } else {\n      var result = consumeEscape(str, index);\n\n      if (result !== null) {\n        var _a = __read(result, 2),\n            lastIndex = _a[0],\n            code_5 = _a[1];\n\n        identChars.push(code_5);\n        index = lastIndex;\n        continue;\n      }\n    }\n\n    break;\n  }\n\n  return [index - 1, String.fromCharCode.apply(null, identChars)];\n};\nvar consumeUrl = function consumeUrl(str, index) {\n  var code = str.charCodeAt(index);\n\n  while (code === 0x0009 || code === 0x0020 || code === 0x000a) {\n    code = str.charCodeAt(++index);\n  }\n\n  var urlChars = [];\n  var hasFinishedWord = false;\n\n  while (index < str.length) {\n    if (code === 0x0029) {\n      return [index, String.fromCharCode.apply(null, urlChars)];\n    } else if (code === 0x0022 || code === 0x0027 || code === 0x0028) {\n      return null;\n    } else if (code === 0x0009 || code === 0x0020 || code === 0x000a) {\n      if (!hasFinishedWord && urlChars.length !== 0) hasFinishedWord = true;\n    } else if (code === 0x005c) {\n      var result = consumeEscape(str, index);\n      if (result === null || hasFinishedWord) return null;\n\n      var _a = __read(result, 2),\n          lastIndex = _a[0],\n          value = _a[1];\n\n      urlChars.push(value);\n      index = lastIndex;\n    } else {\n      if (hasFinishedWord) return null;\n      urlChars.push(code);\n    }\n\n    code = str.charCodeAt(++index);\n  }\n\n  return null;\n};\nvar consumeIdentLike = function consumeIdentLike(str, index) {\n  var result = consumeIdent(str, index);\n  if (result === null) return null;\n\n  var _a = __read(result, 2),\n      lastIndex = _a[0],\n      value = _a[1];\n\n  if (value.toLowerCase() === 'url') {\n    if (str.length > lastIndex + 1) {\n      var nextCode = str.charCodeAt(lastIndex + 1);\n\n      if (nextCode === 0x0028) {\n        for (var offset = 2; lastIndex + offset < str.length; offset += 1) {\n          var nextNextCode = str.charCodeAt(lastIndex + offset);\n\n          if (nextNextCode === 0x0022 || nextNextCode === 0x0027) {\n            return [lastIndex + 1, value.toLowerCase(), '<function-token>'];\n          } else if (nextNextCode !== 0x0009 && nextNextCode !== 0x0020 && nextNextCode !== 0x000a) {\n            var result_1 = consumeUrl(str, lastIndex + offset);\n            if (result_1 === null) return null;\n\n            var _b = __read(result_1, 2),\n                lastUrlIndex = _b[0],\n                value_1 = _b[1];\n\n            return [lastUrlIndex, value_1, '<url-token>'];\n          }\n        }\n\n        return [lastIndex + 1, value.toLowerCase(), '<function-token>'];\n      }\n    }\n  } else if (str.length > lastIndex + 1) {\n    var nextCode = str.charCodeAt(lastIndex + 1);\n\n    if (nextCode === 0x0028) {\n      return [lastIndex + 1, value.toLowerCase(), '<function-token>'];\n    }\n  }\n\n  return [lastIndex, value.toLowerCase(), '<ident-token>'];\n};\n\nvar simplifyAST = function simplifyAST(ast) {\n  for (var i = ast.length - 1; i >= 0; i--) {\n    ast[i] = simplifyMediaQuery(ast[i]);\n  }\n\n  return ast;\n};\n\nvar simplifyMediaQuery = function simplifyMediaQuery(mediaQuery) {\n  if (mediaQuery.mediaCondition === null) return mediaQuery;\n  var mediaCondition = simplifyMediaCondition(mediaQuery.mediaCondition);\n\n  if (mediaCondition.operator === null && mediaCondition.children.length === 1 && 'children' in mediaCondition.children[0]) {\n    mediaCondition = mediaCondition.children[0];\n  }\n\n  return {\n    mediaPrefix: mediaQuery.mediaPrefix,\n    mediaType: mediaQuery.mediaType,\n    mediaCondition: mediaCondition\n  };\n};\n\nvar simplifyMediaCondition = function simplifyMediaCondition(mediaCondition) {\n  for (var i = mediaCondition.children.length - 1; i >= 0; i--) {\n    var unsimplifiedChild = mediaCondition.children[i];\n\n    if (!('context' in unsimplifiedChild)) {\n      var child = simplifyMediaCondition(unsimplifiedChild);\n\n      if (child.operator === null && child.children.length === 1) {\n        mediaCondition.children[i] = child.children[0];\n      } else if (child.operator === mediaCondition.operator && (child.operator === 'and' || child.operator === 'or')) {\n        var spliceArgs = [i, 1];\n\n        for (var i_1 = 0; i_1 < child.children.length; i_1++) {\n          spliceArgs.push(child.children[i_1]);\n        }\n\n        mediaCondition.children.splice.apply(mediaCondition.children, spliceArgs);\n      }\n    }\n  }\n\n  return mediaCondition;\n};\n\nvar createError = function createError(message, err) {\n  if (err instanceof Error) {\n    return new Error(\"\".concat(err.message.trim(), \"\\n\").concat(message.trim()));\n  } else {\n    return new Error(message.trim());\n  }\n};\n\nvar toAST = function toAST(str) {\n  return simplifyAST(toUnflattenedAST(str));\n};\nvar toUnflattenedAST = function toUnflattenedAST(str) {\n  var tokenList = lexicalAnalysis(str.trim());\n\n  if (tokenList === null) {\n    throw createError('Failed tokenizing');\n  }\n\n  var startIndex = 0;\n  var endIndex = tokenList.length - 1;\n\n  if (tokenList[0].type === '<at-keyword-token>' && tokenList[0].value === 'media') {\n    if (tokenList[1].type !== '<whitespace-token>') {\n      throw createError('Expected whitespace after media');\n    }\n\n    startIndex = 2;\n\n    for (var i = 2; i < tokenList.length - 1; i++) {\n      var token = tokenList[i];\n\n      if (token.type === '<{-token>') {\n        endIndex = i;\n        break;\n      } else if (token.type === '<semicolon-token>') {\n        throw createError(\"Expected '{' in media query but found ';'\");\n      }\n    }\n  }\n\n  tokenList = tokenList.slice(startIndex, endIndex);\n  return syntacticAnalysis(tokenList);\n};\nvar removeWhitespace = function removeWhitespace(tokenList) {\n  var newTokenList = [];\n  var before = false;\n\n  for (var i = 0; i < tokenList.length; i++) {\n    if (tokenList[i].type === '<whitespace-token>') {\n      before = true;\n\n      if (newTokenList.length > 0) {\n        newTokenList[newTokenList.length - 1].wsAfter = true;\n      }\n    } else {\n      newTokenList.push(__assign(__assign({}, tokenList[i]), {\n        wsBefore: before,\n        wsAfter: false\n      }));\n      before = false;\n    }\n  }\n\n  return newTokenList;\n};\nvar syntacticAnalysis = function syntacticAnalysis(tokenList) {\n  var e_1, _a;\n\n  var mediaQueryList = [[]];\n\n  for (var i = 0; i < tokenList.length; i++) {\n    var token = tokenList[i];\n\n    if (token.type === '<comma-token>') {\n      mediaQueryList.push([]);\n    } else {\n      mediaQueryList[mediaQueryList.length - 1].push(token);\n    }\n  }\n\n  var mediaQueries = mediaQueryList.map(removeWhitespace);\n\n  if (mediaQueries.length === 1 && mediaQueries[0].length === 0) {\n    return [{\n      mediaCondition: null,\n      mediaPrefix: null,\n      mediaType: 'all'\n    }];\n  } else {\n    var mediaQueryTokens = mediaQueries.map(function (mediaQueryTokens) {\n      if (mediaQueryTokens.length === 0) {\n        return null;\n      } else {\n        return tokenizeMediaQuery(mediaQueryTokens);\n      }\n    });\n    var nonNullMediaQueryTokens = [];\n\n    try {\n      for (var mediaQueryTokens_1 = __values(mediaQueryTokens), mediaQueryTokens_1_1 = mediaQueryTokens_1.next(); !mediaQueryTokens_1_1.done; mediaQueryTokens_1_1 = mediaQueryTokens_1.next()) {\n        var mediaQueryToken = mediaQueryTokens_1_1.value;\n\n        if (mediaQueryToken !== null) {\n          nonNullMediaQueryTokens.push(mediaQueryToken);\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (mediaQueryTokens_1_1 && !mediaQueryTokens_1_1.done && (_a = mediaQueryTokens_1[\"return\"])) _a.call(mediaQueryTokens_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    if (nonNullMediaQueryTokens.length === 0) {\n      throw createError('No valid media queries');\n    }\n\n    return nonNullMediaQueryTokens;\n  }\n};\nvar tokenizeMediaQuery = function tokenizeMediaQuery(tokens) {\n  var firstToken = tokens[0];\n\n  if (firstToken.type === '<(-token>') {\n    try {\n      return {\n        mediaPrefix: null,\n        mediaType: 'all',\n        mediaCondition: tokenizeMediaCondition(tokens, true)\n      };\n    } catch (err) {\n      throw createError(\"Expected media condition after '('\", err);\n    }\n  } else if (firstToken.type === '<ident-token>') {\n    var mediaPrefix = null;\n    var mediaType = void 0;\n    var value = firstToken.value;\n\n    if (value === 'only' || value === 'not') {\n      mediaPrefix = value;\n    }\n\n    var firstIndex = mediaPrefix === null ? 0 : 1;\n\n    if (tokens.length <= firstIndex) {\n      throw createError(\"Expected extra token in media query\");\n    }\n\n    var firstNonUnaryToken = tokens[firstIndex];\n\n    if (firstNonUnaryToken.type === '<ident-token>') {\n      var value_1 = firstNonUnaryToken.value;\n\n      if (value_1 === 'all') {\n        mediaType = 'all';\n      } else if (value_1 === 'print' || value_1 === 'screen') {\n        mediaType = value_1;\n      } else if (value_1 === 'tty' || value_1 === 'tv' || value_1 === 'projection' || value_1 === 'handheld' || value_1 === 'braille' || value_1 === 'embossed' || value_1 === 'aural' || value_1 === 'speech') {\n        mediaPrefix = mediaPrefix === 'not' ? null : 'not';\n        mediaType = 'all';\n      } else {\n        throw createError(\"Unknown ident '\".concat(value_1, \"' in media query\"));\n      }\n    } else if (mediaPrefix === 'not' && firstNonUnaryToken.type === '<(-token>') {\n      var tokensWithParens = [{\n        type: '<(-token>',\n        wsBefore: false,\n        wsAfter: false\n      }];\n      tokensWithParens.push.apply(tokensWithParens, tokens);\n      tokensWithParens.push({\n        type: '<)-token>',\n        wsBefore: false,\n        wsAfter: false\n      });\n\n      try {\n        return {\n          mediaPrefix: null,\n          mediaType: 'all',\n          mediaCondition: tokenizeMediaCondition(tokensWithParens, true)\n        };\n      } catch (err) {\n        throw createError(\"Expected media condition after '('\", err);\n      }\n    } else {\n      throw createError('Invalid media query');\n    }\n\n    if (firstIndex + 1 === tokens.length) {\n      return {\n        mediaPrefix: mediaPrefix,\n        mediaType: mediaType,\n        mediaCondition: null\n      };\n    } else if (firstIndex + 4 < tokens.length) {\n      var secondNonUnaryToken = tokens[firstIndex + 1];\n\n      if (secondNonUnaryToken.type === '<ident-token>' && secondNonUnaryToken.value === 'and') {\n        try {\n          return {\n            mediaPrefix: mediaPrefix,\n            mediaType: mediaType,\n            mediaCondition: tokenizeMediaCondition(tokens.slice(firstIndex + 2), false)\n          };\n        } catch (err) {\n          throw createError(\"Expected media condition after 'and'\", err);\n        }\n      } else {\n        throw createError(\"Expected 'and' after media prefix\");\n      }\n    } else {\n      throw createError('Expected media condition after media prefix');\n    }\n  } else {\n    throw createError('Expected media condition or media prefix');\n  }\n};\nvar tokenizeMediaCondition = function tokenizeMediaCondition(tokens, mayContainOr, previousOperator) {\n  if (previousOperator === void 0) {\n    previousOperator = null;\n  }\n\n  if (tokens.length < 3 || tokens[0].type !== '<(-token>' || tokens[tokens.length - 1].type !== '<)-token>') {\n    throw new Error('Invalid media condition');\n  }\n\n  var endIndexOfFirstFeature = tokens.length - 1;\n  var maxDepth = 0;\n  var count = 0;\n\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i];\n\n    if (token.type === '<(-token>') {\n      count += 1;\n      maxDepth = Math.max(maxDepth, count);\n    } else if (token.type === '<)-token>') {\n      count -= 1;\n    }\n\n    if (count === 0) {\n      endIndexOfFirstFeature = i;\n      break;\n    }\n  }\n\n  if (count !== 0) {\n    throw new Error('Mismatched parens\\nInvalid media condition');\n  }\n\n  var child;\n  var featureTokens = tokens.slice(0, endIndexOfFirstFeature + 1);\n\n  if (maxDepth === 1) {\n    child = tokenizeMediaFeature(featureTokens);\n  } else {\n    if (featureTokens[1].type === '<ident-token>' && featureTokens[1].value === 'not') {\n      child = tokenizeMediaCondition(featureTokens.slice(2, -1), true, 'not');\n    } else {\n      child = tokenizeMediaCondition(featureTokens.slice(1, -1), true);\n    }\n  }\n\n  if (endIndexOfFirstFeature === tokens.length - 1) {\n    return {\n      operator: previousOperator,\n      children: [child]\n    };\n  } else {\n    var nextToken = tokens[endIndexOfFirstFeature + 1];\n\n    if (nextToken.type !== '<ident-token>') {\n      throw new Error('Invalid operator\\nInvalid media condition');\n    } else if (previousOperator !== null && previousOperator !== nextToken.value) {\n      throw new Error(\"'\".concat(nextToken.value, \"' and '\").concat(previousOperator, \"' must not be at same level\\nInvalid media condition\"));\n    } else if (nextToken.value === 'or' && !mayContainOr) {\n      throw new Error(\"Cannot use 'or' at top level of a media query\\nInvalid media condition\");\n    } else if (nextToken.value !== 'and' && nextToken.value !== 'or') {\n      throw new Error(\"Invalid operator: '\".concat(nextToken.value, \"'\\nInvalid media condition\"));\n    }\n\n    var siblings = tokenizeMediaCondition(tokens.slice(endIndexOfFirstFeature + 2), mayContainOr, nextToken.value);\n    return {\n      operator: nextToken.value,\n      children: [child].concat(siblings.children)\n    };\n  }\n};\nvar tokenizeMediaFeature = function tokenizeMediaFeature(rawTokens) {\n  if (rawTokens.length < 3 || rawTokens[0].type !== '<(-token>' || rawTokens[rawTokens.length - 1].type !== '<)-token>') {\n    throw new Error('Invalid media feature');\n  }\n\n  var tokens = [rawTokens[0]];\n\n  for (var i = 1; i < rawTokens.length; i++) {\n    if (i < rawTokens.length - 2) {\n      var a = rawTokens[i];\n      var b = rawTokens[i + 1];\n      var c = rawTokens[i + 2];\n\n      if (a.type === '<number-token>' && a.value > 0 && b.type === '<delim-token>' && b.value === 0x002f && c.type === '<number-token>' && c.value > 0) {\n        tokens.push({\n          type: '<ratio-token>',\n          numerator: a.value,\n          denominator: c.value,\n          wsBefore: a.wsBefore,\n          wsAfter: c.wsAfter\n        });\n        i += 2;\n        continue;\n      }\n    }\n\n    tokens.push(rawTokens[i]);\n  }\n\n  var nextToken = tokens[1];\n\n  if (nextToken.type === '<ident-token>' && tokens.length === 3) {\n    return {\n      context: 'boolean',\n      feature: nextToken.value\n    };\n  } else if (tokens.length === 5 && tokens[1].type === '<ident-token>' && tokens[2].type === '<colon-token>') {\n    var valueToken = tokens[3];\n\n    if (valueToken.type === '<number-token>' || valueToken.type === '<dimension-token>' || valueToken.type === '<ratio-token>' || valueToken.type === '<ident-token>') {\n      var feature = tokens[1].value;\n      var prefix = null;\n      var slice = feature.slice(0, 4);\n\n      if (slice === 'min-') {\n        prefix = 'min';\n        feature = feature.slice(4);\n      } else if (slice === 'max-') {\n        prefix = 'max';\n        feature = feature.slice(4);\n      }\n\n      valueToken.wsBefore;\n          valueToken.wsAfter;\n          var value = __rest(valueToken, [\"wsBefore\", \"wsAfter\"]);\n\n      return {\n        context: 'value',\n        prefix: prefix,\n        feature: feature,\n        value: value\n      };\n    }\n  } else if (tokens.length >= 5) {\n    try {\n      var range = tokenizeRange(tokens);\n      return {\n        context: 'range',\n        feature: range.featureName,\n        range: range\n      };\n    } catch (err) {\n      throw createError('Invalid media feature', err);\n    }\n  }\n\n  throw new Error('Invalid media feature');\n};\nvar tokenizeRange = function tokenizeRange(tokens) {\n  var _a, _b, _c, _d;\n\n  if (tokens.length < 5 || tokens[0].type !== '<(-token>' || tokens[tokens.length - 1].type !== '<)-token>') {\n    throw new Error('Invalid range');\n  }\n\n  var range = {\n    leftToken: null,\n    leftOp: null,\n    featureName: '',\n    rightOp: null,\n    rightToken: null\n  };\n  var hasLeft = tokens[1].type === '<number-token>' || tokens[1].type === '<dimension-token>' || tokens[1].type === '<ratio-token>' || tokens[1].type === '<ident-token>' && tokens[1].value === 'infinite';\n\n  if (tokens[2].type === '<delim-token>') {\n    if (tokens[2].value === 0x003c) {\n      if (tokens[3].type === '<delim-token>' && tokens[3].value === 0x003d && !tokens[3].wsBefore) {\n        range[hasLeft ? 'leftOp' : 'rightOp'] = '<=';\n      } else {\n        range[hasLeft ? 'leftOp' : 'rightOp'] = '<';\n      }\n    } else if (tokens[2].value === 0x003e) {\n      if (tokens[3].type === '<delim-token>' && tokens[3].value === 0x003d && !tokens[3].wsBefore) {\n        range[hasLeft ? 'leftOp' : 'rightOp'] = '>=';\n      } else {\n        range[hasLeft ? 'leftOp' : 'rightOp'] = '>';\n      }\n    } else if (tokens[2].value === 0x003d) {\n      range[hasLeft ? 'leftOp' : 'rightOp'] = '=';\n    } else {\n      throw new Error('Invalid range');\n    }\n\n    if (hasLeft) {\n      range.leftToken = tokens[1];\n    } else if (tokens[1].type === '<ident-token>') {\n      range.featureName = tokens[1].value;\n    } else {\n      throw new Error('Invalid range');\n    }\n\n    var tokenIndexAfterFirstOp = 2 + ((_b = (_a = range[hasLeft ? 'leftOp' : 'rightOp']) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0);\n    var tokenAfterFirstOp = tokens[tokenIndexAfterFirstOp];\n\n    if (hasLeft) {\n      if (tokenAfterFirstOp.type === '<ident-token>') {\n        range.featureName = tokenAfterFirstOp.value;\n\n        if (tokens.length >= 7) {\n          var secondOpToken = tokens[tokenIndexAfterFirstOp + 1];\n          var followingToken = tokens[tokenIndexAfterFirstOp + 2];\n\n          if (secondOpToken.type === '<delim-token>') {\n            var charCode = secondOpToken.value;\n\n            if (charCode === 0x003c) {\n              if (followingToken.type === '<delim-token>' && followingToken.value === 0x003d && !followingToken.wsBefore) {\n                range.rightOp = '<=';\n              } else {\n                range.rightOp = '<';\n              }\n            } else if (charCode === 0x003e) {\n              if (followingToken.type === '<delim-token>' && followingToken.value === 0x003d && !followingToken.wsBefore) {\n                range.rightOp = '>=';\n              } else {\n                range.rightOp = '>';\n              }\n            } else {\n              throw new Error('Invalid range');\n            }\n\n            var tokenAfterSecondOp = tokens[tokenIndexAfterFirstOp + 1 + ((_d = (_c = range.rightOp) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0)];\n            range.rightToken = tokenAfterSecondOp;\n          } else {\n            throw new Error('Invalid range');\n          }\n        } else if (tokenIndexAfterFirstOp + 2 !== tokens.length) {\n          throw new Error('Invalid range');\n        }\n      } else {\n        throw new Error('Invalid range');\n      }\n    } else {\n      range.rightToken = tokenAfterFirstOp;\n    }\n\n    var validRange = null;\n    var lt = range.leftToken,\n        leftOp = range.leftOp,\n        featureName = range.featureName,\n        rightOp = range.rightOp,\n        rt = range.rightToken;\n    var leftToken = null;\n\n    if (lt !== null) {\n      if (lt.type === '<ident-token>') {\n        var type = lt.type,\n            value = lt.value;\n\n        if (value === 'infinite') {\n          leftToken = {\n            type: type,\n            value: value\n          };\n        }\n      } else if (lt.type === '<number-token>' || lt.type === '<dimension-token>' || lt.type === '<ratio-token>') {\n        lt.wsBefore;\n            lt.wsAfter;\n            var ltNoWS = __rest(lt, [\"wsBefore\", \"wsAfter\"]);\n\n        leftToken = ltNoWS;\n      }\n    }\n\n    var rightToken = null;\n\n    if (rt !== null) {\n      if (rt.type === '<ident-token>') {\n        var type = rt.type,\n            value = rt.value;\n\n        if (value === 'infinite') {\n          rightToken = {\n            type: type,\n            value: value\n          };\n        }\n      } else if (rt.type === '<number-token>' || rt.type === '<dimension-token>' || rt.type === '<ratio-token>') {\n        rt.wsBefore;\n            rt.wsAfter;\n            var rtNoWS = __rest(rt, [\"wsBefore\", \"wsAfter\"]);\n\n        rightToken = rtNoWS;\n      }\n    }\n\n    if (leftToken !== null && rightToken !== null) {\n      if ((leftOp === '<' || leftOp === '<=') && (rightOp === '<' || rightOp === '<=')) {\n        validRange = {\n          leftToken: leftToken,\n          leftOp: leftOp,\n          featureName: featureName,\n          rightOp: rightOp,\n          rightToken: rightToken\n        };\n      } else if ((leftOp === '>' || leftOp === '>=') && (rightOp === '>' || rightOp === '>=')) {\n        validRange = {\n          leftToken: leftToken,\n          leftOp: leftOp,\n          featureName: featureName,\n          rightOp: rightOp,\n          rightToken: rightToken\n        };\n      } else {\n        throw new Error('Invalid range');\n      }\n    } else if (leftToken === null && leftOp === null && rightOp !== null && rightToken !== null) {\n      validRange = {\n        leftToken: leftToken,\n        leftOp: leftOp,\n        featureName: featureName,\n        rightOp: rightOp,\n        rightToken: rightToken\n      };\n    } else if (leftToken !== null && leftOp !== null && rightOp === null && rightToken === null) {\n      validRange = {\n        leftToken: leftToken,\n        leftOp: leftOp,\n        featureName: featureName,\n        rightOp: rightOp,\n        rightToken: rightToken\n      };\n    }\n\n    return validRange;\n  } else {\n    throw new Error('Invalid range');\n  }\n};\n\n\n//# sourceMappingURL=media-query-parser.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVkaWEtcXVlcnktcGFyc2VyL2Rpc3QvbWVkaWEtcXVlcnktcGFyc2VyLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLG9CQUFvQjtBQUM3Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBLGlCQUFpQjtBQUNqQixPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0EsaUJBQWlCO0FBQ2pCLE9BQU87QUFDUCxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLGdCQUFnQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBLFdBQVcsU0FBUztBQUNwQjs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHlDQUF5QyxvQkFBb0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseUNBQXlDLG9CQUFvQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixpQ0FBaUM7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsUUFBUTtBQUN2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQsUUFBUTtBQUMzRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUEsMEJBQTBCLDZCQUE2QjtBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQiwwQkFBMEI7QUFDOUM7O0FBRUEsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isc0NBQXNDLDZCQUE2QjtBQUNuRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNENBQTRDO0FBQzVDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixzQkFBc0I7QUFDeEM7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxrSEFBa0gsNEJBQTRCO0FBQzlJOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsbUJBQW1CO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRTZUO0FBQzdUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnV0dXJvcGFsLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9tZWRpYS1xdWVyeS1wYXJzZXIvZGlzdC9tZWRpYS1xdWVyeS1wYXJzZXIuZXNtLmpzP2M3MzkiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIEBsaWNlbnNlIE1lZGlhUXVlcnlQYXJzZXIgLSBNSVQgTGljZW5zZSAtIFRvbSBHb2xkZW4gKGdpdGh1YkB0Ympnb2xkZW4uY29tKSAqL1xuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxudmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cblxudmFyIHdlaXJkTmV3bGluZXMgPSAvKFxcdTAwMER8XFx1MDAwQ3xcXHUwMDBEXFx1MDAwQSkvZztcbnZhciBudWxsT3JTdXJyb2dhdGVzID0gL1tcXHUwMDAwXFx1RDgwMC1cXHVERkZGXS9nO1xudmFyIGNvbW1lbnRSZWdleCA9IC8oXFwvXFwqKVtcXHNcXFNdKj8oXFwqXFwvKS9nO1xudmFyIGxleGljYWxBbmFseXNpcyA9IGZ1bmN0aW9uIGxleGljYWxBbmFseXNpcyhzdHIsIGluZGV4KSB7XG4gIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgaW5kZXggPSAwO1xuICB9XG5cbiAgc3RyID0gc3RyLnJlcGxhY2Uod2VpcmROZXdsaW5lcywgJ1xcbicpLnJlcGxhY2UobnVsbE9yU3Vycm9nYXRlcywgXCJcXHVGRkZEXCIpO1xuICBzdHIgPSBzdHIucmVwbGFjZShjb21tZW50UmVnZXgsICcnKTtcbiAgdmFyIHRva2VucyA9IFtdO1xuXG4gIGZvciAoOyBpbmRleCA8IHN0ci5sZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICB2YXIgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGluZGV4KTtcblxuICAgIGlmIChjb2RlID09PSAweDAwMDkgfHwgY29kZSA9PT0gMHgwMDIwIHx8IGNvZGUgPT09IDB4MDAwYSkge1xuICAgICAgdmFyIGNvZGVfMSA9IHN0ci5jaGFyQ29kZUF0KCsraW5kZXgpO1xuXG4gICAgICB3aGlsZSAoY29kZV8xID09PSAweDAwMDkgfHwgY29kZV8xID09PSAweDAwMjAgfHwgY29kZV8xID09PSAweDAwMGEpIHtcbiAgICAgICAgY29kZV8xID0gc3RyLmNoYXJDb2RlQXQoKytpbmRleCk7XG4gICAgICB9XG5cbiAgICAgIGluZGV4IC09IDE7XG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICc8d2hpdGVzcGFjZS10b2tlbj4nXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDAyMikge1xuICAgICAgdmFyIHJlc3VsdCA9IGNvbnN1bWVTdHJpbmcoc3RyLCBpbmRleCk7XG5cbiAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBfYSA9IF9fcmVhZChyZXN1bHQsIDIpLFxuICAgICAgICAgIGxhc3RJbmRleCA9IF9hWzBdLFxuICAgICAgICAgIHZhbHVlID0gX2FbMV07XG5cbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJzxzdHJpbmctdG9rZW4+JyxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICAgIGluZGV4ID0gbGFzdEluZGV4O1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwMDIzKSB7XG4gICAgICBpZiAoaW5kZXggKyAxIDwgc3RyLmxlbmd0aCkge1xuICAgICAgICB2YXIgbmV4dENvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCArIDEpO1xuXG4gICAgICAgIGlmIChuZXh0Q29kZSA9PT0gMHgwMDVmIHx8IG5leHRDb2RlID49IDB4MDA0MSAmJiBuZXh0Q29kZSA8PSAweDAwNWEgfHwgbmV4dENvZGUgPj0gMHgwMDYxICYmIG5leHRDb2RlIDw9IDB4MDA3YSB8fCBuZXh0Q29kZSA+PSAweDAwODAgfHwgbmV4dENvZGUgPj0gMHgwMDMwICYmIG5leHRDb2RlIDw9IDB4MDAzOSB8fCBuZXh0Q29kZSA9PT0gMHgwMDVjICYmIGluZGV4ICsgMiA8IHN0ci5sZW5ndGggJiYgc3RyLmNoYXJDb2RlQXQoaW5kZXggKyAyKSAhPT0gMHgwMDBhKSB7XG4gICAgICAgICAgdmFyIGZsYWcgPSB3b3VsZFN0YXJ0SWRlbnRpZmllcihzdHIsIGluZGV4ICsgMSkgPyAnaWQnIDogJ3VucmVzdHJpY3RlZCc7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGNvbnN1bWVJZGVudFVuc2FmZShzdHIsIGluZGV4ICsgMSk7XG5cbiAgICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgX2IgPSBfX3JlYWQocmVzdWx0LCAyKSxcbiAgICAgICAgICAgICAgICBsYXN0SW5kZXggPSBfYlswXSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IF9iWzFdO1xuXG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgIHR5cGU6ICc8aGFzaC10b2tlbj4nLFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgZmxhZzogZmxhZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICc8ZGVsaW0tdG9rZW4+JyxcbiAgICAgICAgdmFsdWU6IGNvZGVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwMDI3KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gY29uc3VtZVN0cmluZyhzdHIsIGluZGV4KTtcblxuICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIF9jID0gX19yZWFkKHJlc3VsdCwgMiksXG4gICAgICAgICAgbGFzdEluZGV4ID0gX2NbMF0sXG4gICAgICAgICAgdmFsdWUgPSBfY1sxXTtcblxuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnPHN0cmluZy10b2tlbj4nLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgICAgaW5kZXggPSBsYXN0SW5kZXg7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwMjgpIHtcbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJzwoLXRva2VuPidcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwMDI5KSB7XG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICc8KS10b2tlbj4nXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDAyYikge1xuICAgICAgdmFyIHBsdXNOdW1lcmljID0gY29uc3VtZU51bWVyaWMoc3RyLCBpbmRleCk7XG5cbiAgICAgIGlmIChwbHVzTnVtZXJpYyA9PT0gbnVsbCkge1xuICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogJzxkZWxpbS10b2tlbj4nLFxuICAgICAgICAgIHZhbHVlOiBjb2RlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9kID0gX19yZWFkKHBsdXNOdW1lcmljLCAyKSxcbiAgICAgICAgICAgIGxhc3RJbmRleCA9IF9kWzBdLFxuICAgICAgICAgICAgdG9rZW5UdXBsZSA9IF9kWzFdO1xuXG4gICAgICAgIGlmICh0b2tlblR1cGxlWzBdID09PSAnPGRpbWVuc2lvbi10b2tlbj4nKSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJzxkaW1lbnNpb24tdG9rZW4+JyxcbiAgICAgICAgICAgIHZhbHVlOiB0b2tlblR1cGxlWzFdLFxuICAgICAgICAgICAgdW5pdDogdG9rZW5UdXBsZVsyXS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgZmxhZzogJ251bWJlcidcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0b2tlblR1cGxlWzBdID09PSAnPG51bWJlci10b2tlbj4nKSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogdG9rZW5UdXBsZVswXSxcbiAgICAgICAgICAgIHZhbHVlOiB0b2tlblR1cGxlWzFdLFxuICAgICAgICAgICAgZmxhZzogdG9rZW5UdXBsZVsyXVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IHRva2VuVHVwbGVbMF0sXG4gICAgICAgICAgICB2YWx1ZTogdG9rZW5UdXBsZVsxXSxcbiAgICAgICAgICAgIGZsYWc6ICdudW1iZXInXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpbmRleCA9IGxhc3RJbmRleDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDAyYykge1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnPGNvbW1hLXRva2VuPidcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwMDJkKSB7XG4gICAgICB2YXIgbWludXNOdW1lcmljID0gY29uc3VtZU51bWVyaWMoc3RyLCBpbmRleCk7XG5cbiAgICAgIGlmIChtaW51c051bWVyaWMgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIF9lID0gX19yZWFkKG1pbnVzTnVtZXJpYywgMiksXG4gICAgICAgICAgICBsYXN0SW5kZXggPSBfZVswXSxcbiAgICAgICAgICAgIHRva2VuVHVwbGUgPSBfZVsxXTtcblxuICAgICAgICBpZiAodG9rZW5UdXBsZVswXSA9PT0gJzxkaW1lbnNpb24tdG9rZW4+Jykge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICc8ZGltZW5zaW9uLXRva2VuPicsXG4gICAgICAgICAgICB2YWx1ZTogdG9rZW5UdXBsZVsxXSxcbiAgICAgICAgICAgIHVuaXQ6IHRva2VuVHVwbGVbMl0udG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgIGZsYWc6ICdudW1iZXInXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodG9rZW5UdXBsZVswXSA9PT0gJzxudW1iZXItdG9rZW4+Jykge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IHRva2VuVHVwbGVbMF0sXG4gICAgICAgICAgICB2YWx1ZTogdG9rZW5UdXBsZVsxXSxcbiAgICAgICAgICAgIGZsYWc6IHRva2VuVHVwbGVbMl1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiB0b2tlblR1cGxlWzBdLFxuICAgICAgICAgICAgdmFsdWU6IHRva2VuVHVwbGVbMV0sXG4gICAgICAgICAgICBmbGFnOiAnbnVtYmVyJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXggKyAyIDwgc3RyLmxlbmd0aCkge1xuICAgICAgICB2YXIgbmV4dENvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCArIDEpO1xuICAgICAgICB2YXIgbmV4dE5leHRDb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXggKyAyKTtcblxuICAgICAgICBpZiAobmV4dENvZGUgPT09IDB4MDAyZCAmJiBuZXh0TmV4dENvZGUgPT09IDB4MDAzZSkge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICc8Q0RDLXRva2VuPidcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpbmRleCArPSAyO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBjb25zdW1lSWRlbnRMaWtlKHN0ciwgaW5kZXgpO1xuXG4gICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBfZiA9IF9fcmVhZChyZXN1bHQsIDMpLFxuICAgICAgICAgICAgbGFzdEluZGV4ID0gX2ZbMF0sXG4gICAgICAgICAgICB2YWx1ZSA9IF9mWzFdLFxuICAgICAgICAgICAgdHlwZSA9IF9mWzJdO1xuXG4gICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgaW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICc8ZGVsaW0tdG9rZW4+JyxcbiAgICAgICAgdmFsdWU6IGNvZGVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwMDJlKSB7XG4gICAgICB2YXIgbWludXNOdW1lcmljID0gY29uc3VtZU51bWVyaWMoc3RyLCBpbmRleCk7XG5cbiAgICAgIGlmIChtaW51c051bWVyaWMgPT09IG51bGwpIHtcbiAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgIHR5cGU6ICc8ZGVsaW0tdG9rZW4+JyxcbiAgICAgICAgICB2YWx1ZTogY29kZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfZyA9IF9fcmVhZChtaW51c051bWVyaWMsIDIpLFxuICAgICAgICAgICAgbGFzdEluZGV4ID0gX2dbMF0sXG4gICAgICAgICAgICB0b2tlblR1cGxlID0gX2dbMV07XG5cbiAgICAgICAgaWYgKHRva2VuVHVwbGVbMF0gPT09ICc8ZGltZW5zaW9uLXRva2VuPicpIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnPGRpbWVuc2lvbi10b2tlbj4nLFxuICAgICAgICAgICAgdmFsdWU6IHRva2VuVHVwbGVbMV0sXG4gICAgICAgICAgICB1bml0OiB0b2tlblR1cGxlWzJdLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICBmbGFnOiAnbnVtYmVyJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRva2VuVHVwbGVbMF0gPT09ICc8bnVtYmVyLXRva2VuPicpIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiB0b2tlblR1cGxlWzBdLFxuICAgICAgICAgICAgdmFsdWU6IHRva2VuVHVwbGVbMV0sXG4gICAgICAgICAgICBmbGFnOiB0b2tlblR1cGxlWzJdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogdG9rZW5UdXBsZVswXSxcbiAgICAgICAgICAgIHZhbHVlOiB0b2tlblR1cGxlWzFdLFxuICAgICAgICAgICAgZmxhZzogJ251bWJlcidcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDAzYSkge1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnPGNvbG9uLXRva2VuPidcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwMDNiKSB7XG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICc8c2VtaWNvbG9uLXRva2VuPidcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwMDNjKSB7XG4gICAgICBpZiAoaW5kZXggKyAzIDwgc3RyLmxlbmd0aCkge1xuICAgICAgICB2YXIgbmV4dENvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCArIDEpO1xuICAgICAgICB2YXIgbmV4dE5leHRDb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXggKyAyKTtcbiAgICAgICAgdmFyIG5leHROZXh0TmV4dENvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCArIDMpO1xuXG4gICAgICAgIGlmIChuZXh0Q29kZSA9PT0gMHgwMDIxICYmIG5leHROZXh0Q29kZSA9PT0gMHgwMDJkICYmIG5leHROZXh0TmV4dENvZGUgPT09IDB4MDAyZCkge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICc8Q0RPLXRva2VuPidcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpbmRleCArPSAzO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJzxkZWxpbS10b2tlbj4nLFxuICAgICAgICB2YWx1ZTogY29kZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwNDApIHtcbiAgICAgIHZhciByZXN1bHQgPSBjb25zdW1lSWRlbnQoc3RyLCBpbmRleCArIDEpO1xuXG4gICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBfaCA9IF9fcmVhZChyZXN1bHQsIDIpLFxuICAgICAgICAgICAgbGFzdEluZGV4ID0gX2hbMF0sXG4gICAgICAgICAgICB2YWx1ZSA9IF9oWzFdO1xuXG4gICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAnPGF0LWtleXdvcmQtdG9rZW4+JyxcbiAgICAgICAgICB2YWx1ZTogdmFsdWUudG9Mb3dlckNhc2UoKVxuICAgICAgICB9KTtcbiAgICAgICAgaW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICc8ZGVsaW0tdG9rZW4+JyxcbiAgICAgICAgdmFsdWU6IGNvZGVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwMDViKSB7XG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICc8Wy10b2tlbj4nXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDA1Yykge1xuICAgICAgdmFyIHJlc3VsdCA9IGNvbnN1bWVFc2NhcGUoc3RyLCBpbmRleCk7XG5cbiAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBfaiA9IF9fcmVhZChyZXN1bHQsIDIpLFxuICAgICAgICAgIGxhc3RJbmRleCA9IF9qWzBdLFxuICAgICAgICAgIHZhbHVlID0gX2pbMV07XG5cbiAgICAgIHN0ciA9IHN0ci5zbGljZSgwLCBpbmRleCkgKyB2YWx1ZSArIHN0ci5zbGljZShsYXN0SW5kZXggKyAxKTtcbiAgICAgIGluZGV4IC09IDE7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwNWQpIHtcbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJzxdLXRva2VuPidcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwMDdiKSB7XG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICc8ey10b2tlbj4nXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDA3ZCkge1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnPH0tdG9rZW4+J1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjb2RlID49IDB4MDAzMCAmJiBjb2RlIDw9IDB4MDAzOSkge1xuICAgICAgdmFyIHJlc3VsdCA9IGNvbnN1bWVOdW1lcmljKHN0ciwgaW5kZXgpO1xuXG4gICAgICB2YXIgX2sgPSBfX3JlYWQocmVzdWx0LCAyKSxcbiAgICAgICAgICBsYXN0SW5kZXggPSBfa1swXSxcbiAgICAgICAgICB0b2tlblR1cGxlID0gX2tbMV07XG5cbiAgICAgIGlmICh0b2tlblR1cGxlWzBdID09PSAnPGRpbWVuc2lvbi10b2tlbj4nKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAnPGRpbWVuc2lvbi10b2tlbj4nLFxuICAgICAgICAgIHZhbHVlOiB0b2tlblR1cGxlWzFdLFxuICAgICAgICAgIHVuaXQ6IHRva2VuVHVwbGVbMl0udG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICBmbGFnOiAnbnVtYmVyJ1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAodG9rZW5UdXBsZVswXSA9PT0gJzxudW1iZXItdG9rZW4+Jykge1xuICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogdG9rZW5UdXBsZVswXSxcbiAgICAgICAgICB2YWx1ZTogdG9rZW5UdXBsZVsxXSxcbiAgICAgICAgICBmbGFnOiB0b2tlblR1cGxlWzJdXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgIHR5cGU6IHRva2VuVHVwbGVbMF0sXG4gICAgICAgICAgdmFsdWU6IHRva2VuVHVwbGVbMV0sXG4gICAgICAgICAgZmxhZzogJ251bWJlcidcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGluZGV4ID0gbGFzdEluZGV4O1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwMDVmIHx8IGNvZGUgPj0gMHgwMDQxICYmIGNvZGUgPD0gMHgwMDVhIHx8IGNvZGUgPj0gMHgwMDYxICYmIGNvZGUgPD0gMHgwMDdhIHx8IGNvZGUgPj0gMHgwMDgwKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gY29uc3VtZUlkZW50TGlrZShzdHIsIGluZGV4KTtcblxuICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIF9sID0gX19yZWFkKHJlc3VsdCwgMyksXG4gICAgICAgICAgbGFzdEluZGV4ID0gX2xbMF0sXG4gICAgICAgICAgdmFsdWUgPSBfbFsxXSxcbiAgICAgICAgICB0eXBlID0gX2xbMl07XG5cbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICAgIGluZGV4ID0gbGFzdEluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICc8ZGVsaW0tdG9rZW4+JyxcbiAgICAgICAgdmFsdWU6IGNvZGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHRva2Vucy5wdXNoKHtcbiAgICB0eXBlOiAnPEVPRi10b2tlbj4nXG4gIH0pO1xuICByZXR1cm4gdG9rZW5zO1xufTtcbnZhciBjb25zdW1lU3RyaW5nID0gZnVuY3Rpb24gY29uc3VtZVN0cmluZyhzdHIsIGluZGV4KSB7XG4gIGlmIChzdHIubGVuZ3RoIDw9IGluZGV4ICsgMSkgcmV0dXJuIG51bGw7XG4gIHZhciBmaXJzdENvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCk7XG4gIHZhciBjaGFyQ29kZXMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gaW5kZXggKyAxOyBpIDwgc3RyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcblxuICAgIGlmIChjb2RlID09PSBmaXJzdENvZGUpIHtcbiAgICAgIHJldHVybiBbaSwgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBjaGFyQ29kZXMpXTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDA1Yykge1xuICAgICAgdmFyIHJlc3VsdCA9IGNvbnN1bWVFc2NhcGUoc3RyLCBpKTtcbiAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHJldHVybiBudWxsO1xuXG4gICAgICB2YXIgX2EgPSBfX3JlYWQocmVzdWx0LCAyKSxcbiAgICAgICAgICBsYXN0SW5kZXggPSBfYVswXSxcbiAgICAgICAgICBjaGFyQ29kZSA9IF9hWzFdO1xuXG4gICAgICBjaGFyQ29kZXMucHVzaChjaGFyQ29kZSk7XG4gICAgICBpID0gbGFzdEluZGV4O1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwMDBhKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hhckNvZGVzLnB1c2goY29kZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xudmFyIHdvdWxkU3RhcnRJZGVudGlmaWVyID0gZnVuY3Rpb24gd291bGRTdGFydElkZW50aWZpZXIoc3RyLCBpbmRleCkge1xuICBpZiAoc3RyLmxlbmd0aCA8PSBpbmRleCkgcmV0dXJuIGZhbHNlO1xuICB2YXIgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGluZGV4KTtcblxuICBpZiAoY29kZSA9PT0gMHgwMDJkKSB7XG4gICAgaWYgKHN0ci5sZW5ndGggPD0gaW5kZXggKyAxKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIG5leHRDb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXggKyAxKTtcblxuICAgIGlmIChuZXh0Q29kZSA9PT0gMHgwMDJkIHx8IG5leHRDb2RlID09PSAweDAwNWYgfHwgbmV4dENvZGUgPj0gMHgwMDQxICYmIG5leHRDb2RlIDw9IDB4MDA1YSB8fCBuZXh0Q29kZSA+PSAweDAwNjEgJiYgbmV4dENvZGUgPD0gMHgwMDdhIHx8IG5leHRDb2RlID49IDB4MDA4MCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChuZXh0Q29kZSA9PT0gMHgwMDVjKSB7XG4gICAgICBpZiAoc3RyLmxlbmd0aCA8PSBpbmRleCArIDIpIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBuZXh0TmV4dENvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCArIDIpO1xuICAgICAgcmV0dXJuIG5leHROZXh0Q29kZSAhPT0gMHgwMDBhO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDA1ZiB8fCBjb2RlID49IDB4MDA0MSAmJiBjb2RlIDw9IDB4MDA1YSB8fCBjb2RlID49IDB4MDA2MSAmJiBjb2RlIDw9IDB4MDA3YSB8fCBjb2RlID49IDB4MDA4MCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDA1Yykge1xuICAgIGlmIChzdHIubGVuZ3RoIDw9IGluZGV4ICsgMSkgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBuZXh0Q29kZSA9IHN0ci5jaGFyQ29kZUF0KGluZGV4ICsgMSk7XG4gICAgcmV0dXJuIG5leHRDb2RlICE9PSAweDAwMGE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xudmFyIGNvbnN1bWVFc2NhcGUgPSBmdW5jdGlvbiBjb25zdW1lRXNjYXBlKHN0ciwgaW5kZXgpIHtcbiAgaWYgKHN0ci5sZW5ndGggPD0gaW5kZXggKyAxKSByZXR1cm4gbnVsbDtcbiAgaWYgKHN0ci5jaGFyQ29kZUF0KGluZGV4KSAhPT0gMHgwMDVjKSByZXR1cm4gbnVsbDtcbiAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCArIDEpO1xuXG4gIGlmIChjb2RlID09PSAweDAwMGEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIGlmIChjb2RlID49IDB4MDAzMCAmJiBjb2RlIDw9IDB4MDAzOSB8fCBjb2RlID49IDB4MDA0MSAmJiBjb2RlIDw9IDB4MDA0NiB8fCBjb2RlID49IDB4MDA2MSAmJiBjb2RlIDw9IDB4MDA2Nikge1xuICAgIHZhciBoZXhDaGFyQ29kZXMgPSBbY29kZV07XG4gICAgdmFyIG1pbiA9IE1hdGgubWluKGluZGV4ICsgNywgc3RyLmxlbmd0aCk7XG4gICAgdmFyIGkgPSBpbmRleCArIDI7XG5cbiAgICBmb3IgKDsgaSA8IG1pbjsgaSArPSAxKSB7XG4gICAgICB2YXIgY29kZV8yID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgIGlmIChjb2RlXzIgPj0gMHgwMDMwICYmIGNvZGVfMiA8PSAweDAwMzkgfHwgY29kZV8yID49IDB4MDA0MSAmJiBjb2RlXzIgPD0gMHgwMDQ2IHx8IGNvZGVfMiA+PSAweDAwNjEgJiYgY29kZV8yIDw9IDB4MDA2Nikge1xuICAgICAgICBoZXhDaGFyQ29kZXMucHVzaChjb2RlXzIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGkgPCBzdHIubGVuZ3RoKSB7XG4gICAgICB2YXIgY29kZV8zID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgIGlmIChjb2RlXzMgPT09IDB4MDAwOSB8fCBjb2RlXzMgPT09IDB4MDAyMCB8fCBjb2RlXzMgPT09IDB4MDAwYSkge1xuICAgICAgICBpICs9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtpIC0gMSwgcGFyc2VJbnQoU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBoZXhDaGFyQ29kZXMpLCAxNildO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbaW5kZXggKyAxLCBjb2RlXTtcbiAgfVxufTtcbnZhciBjb25zdW1lTnVtZXJpYyA9IGZ1bmN0aW9uIGNvbnN1bWVOdW1lcmljKHN0ciwgaW5kZXgpIHtcbiAgdmFyIG51bWJlclJlc3VsdCA9IGNvbnN1bWVOdW1iZXIoc3RyLCBpbmRleCk7XG4gIGlmIChudW1iZXJSZXN1bHQgPT09IG51bGwpIHJldHVybiBudWxsO1xuXG4gIHZhciBfYSA9IF9fcmVhZChudW1iZXJSZXN1bHQsIDMpLFxuICAgICAgbnVtYmVyRW5kSW5kZXggPSBfYVswXSxcbiAgICAgIG51bWJlclZhbHVlID0gX2FbMV0sXG4gICAgICBudW1iZXJGbGFnID0gX2FbMl07XG5cbiAgdmFyIGlkZW50UmVzdWx0ID0gY29uc3VtZUlkZW50KHN0ciwgbnVtYmVyRW5kSW5kZXggKyAxKTtcblxuICBpZiAoaWRlbnRSZXN1bHQgIT09IG51bGwpIHtcbiAgICB2YXIgX2IgPSBfX3JlYWQoaWRlbnRSZXN1bHQsIDIpLFxuICAgICAgICBpZGVudEVuZEluZGV4ID0gX2JbMF0sXG4gICAgICAgIGlkZW50VmFsdWUgPSBfYlsxXTtcblxuICAgIHJldHVybiBbaWRlbnRFbmRJbmRleCwgWyc8ZGltZW5zaW9uLXRva2VuPicsIG51bWJlclZhbHVlLCBpZGVudFZhbHVlXV07XG4gIH1cblxuICBpZiAobnVtYmVyRW5kSW5kZXggKyAxIDwgc3RyLmxlbmd0aCAmJiBzdHIuY2hhckNvZGVBdChudW1iZXJFbmRJbmRleCArIDEpID09PSAweDAwMjUpIHtcbiAgICByZXR1cm4gW251bWJlckVuZEluZGV4ICsgMSwgWyc8cGVyY2VudGFnZS10b2tlbj4nLCBudW1iZXJWYWx1ZV1dO1xuICB9XG5cbiAgcmV0dXJuIFtudW1iZXJFbmRJbmRleCwgWyc8bnVtYmVyLXRva2VuPicsIG51bWJlclZhbHVlLCBudW1iZXJGbGFnXV07XG59O1xudmFyIGNvbnN1bWVOdW1iZXIgPSBmdW5jdGlvbiBjb25zdW1lTnVtYmVyKHN0ciwgaW5kZXgpIHtcbiAgaWYgKHN0ci5sZW5ndGggPD0gaW5kZXgpIHJldHVybiBudWxsO1xuICB2YXIgZmxhZyA9ICdpbnRlZ2VyJztcbiAgdmFyIG51bWJlckNoYXJzID0gW107XG4gIHZhciBmaXJzdENvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCk7XG5cbiAgaWYgKGZpcnN0Q29kZSA9PT0gMHgwMDJiIHx8IGZpcnN0Q29kZSA9PT0gMHgwMDJkKSB7XG4gICAgaW5kZXggKz0gMTtcbiAgICBpZiAoZmlyc3RDb2RlID09PSAweDAwMmQpIG51bWJlckNoYXJzLnB1c2goMHgwMDJkKTtcbiAgfVxuXG4gIHdoaWxlIChpbmRleCA8IHN0ci5sZW5ndGgpIHtcbiAgICB2YXIgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGluZGV4KTtcblxuICAgIGlmIChjb2RlID49IDB4MDAzMCAmJiBjb2RlIDw9IDB4MDAzOSkge1xuICAgICAgbnVtYmVyQ2hhcnMucHVzaChjb2RlKTtcbiAgICAgIGluZGV4ICs9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpbmRleCArIDEgPCBzdHIubGVuZ3RoKSB7XG4gICAgdmFyIG5leHRDb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgIHZhciBuZXh0TmV4dENvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCArIDEpO1xuXG4gICAgaWYgKG5leHRDb2RlID09PSAweDAwMmUgJiYgbmV4dE5leHRDb2RlID49IDB4MDAzMCAmJiBuZXh0TmV4dENvZGUgPD0gMHgwMDM5KSB7XG4gICAgICBudW1iZXJDaGFycy5wdXNoKG5leHRDb2RlLCBuZXh0TmV4dENvZGUpO1xuICAgICAgZmxhZyA9ICdudW1iZXInO1xuICAgICAgaW5kZXggKz0gMjtcblxuICAgICAgd2hpbGUgKGluZGV4IDwgc3RyLmxlbmd0aCkge1xuICAgICAgICB2YXIgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGluZGV4KTtcblxuICAgICAgICBpZiAoY29kZSA+PSAweDAwMzAgJiYgY29kZSA8PSAweDAwMzkpIHtcbiAgICAgICAgICBudW1iZXJDaGFycy5wdXNoKGNvZGUpO1xuICAgICAgICAgIGluZGV4ICs9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoaW5kZXggKyAxIDwgc3RyLmxlbmd0aCkge1xuICAgIHZhciBuZXh0Q29kZSA9IHN0ci5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICB2YXIgbmV4dE5leHRDb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXggKyAxKTtcbiAgICB2YXIgbmV4dE5leHROZXh0Q29kZSA9IHN0ci5jaGFyQ29kZUF0KGluZGV4ICsgMik7XG5cbiAgICBpZiAobmV4dENvZGUgPT09IDB4MDA0NSB8fCBuZXh0Q29kZSA9PT0gMHgwMDY1KSB7XG4gICAgICB2YXIgbmV4dE5leHRJc0RpZ2l0ID0gbmV4dE5leHRDb2RlID49IDB4MDAzMCAmJiBuZXh0TmV4dENvZGUgPD0gMHgwMDM5O1xuXG4gICAgICBpZiAobmV4dE5leHRJc0RpZ2l0IHx8IChuZXh0TmV4dENvZGUgPT09IDB4MDAyYiB8fCBuZXh0TmV4dENvZGUgPT09IDB4MDAyZCkgJiYgbmV4dE5leHROZXh0Q29kZSA+PSAweDAwMzAgJiYgbmV4dE5leHROZXh0Q29kZSA8PSAweDAwMzkpIHtcbiAgICAgICAgZmxhZyA9ICdudW1iZXInO1xuXG4gICAgICAgIGlmIChuZXh0TmV4dElzRGlnaXQpIHtcbiAgICAgICAgICBudW1iZXJDaGFycy5wdXNoKDB4MDA0NSwgbmV4dE5leHRDb2RlKTtcbiAgICAgICAgICBpbmRleCArPSAyO1xuICAgICAgICB9IGVsc2UgaWYgKG5leHROZXh0Q29kZSA9PT0gMHgwMDJkKSB7XG4gICAgICAgICAgbnVtYmVyQ2hhcnMucHVzaCgweDAwNDUsIDB4MDAyZCwgbmV4dE5leHROZXh0Q29kZSk7XG4gICAgICAgICAgaW5kZXggKz0gMztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBudW1iZXJDaGFycy5wdXNoKDB4MDA0NSwgbmV4dE5leHROZXh0Q29kZSk7XG4gICAgICAgICAgaW5kZXggKz0gMztcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGluZGV4KTtcblxuICAgICAgICAgIGlmIChjb2RlID49IDB4MDAzMCAmJiBjb2RlIDw9IDB4MDAzOSkge1xuICAgICAgICAgICAgbnVtYmVyQ2hhcnMucHVzaChjb2RlKTtcbiAgICAgICAgICAgIGluZGV4ICs9IDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBudW1iZXJTdHJpbmcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG51bWJlckNoYXJzKTtcbiAgdmFyIHZhbHVlID0gZmxhZyA9PT0gJ251bWJlcicgPyBwYXJzZUZsb2F0KG51bWJlclN0cmluZykgOiBwYXJzZUludChudW1iZXJTdHJpbmcpO1xuICBpZiAodmFsdWUgPT09IC0wKSB2YWx1ZSA9IDA7XG4gIHJldHVybiBOdW1iZXIuaXNOYU4odmFsdWUpID8gbnVsbCA6IFtpbmRleCAtIDEsIHZhbHVlLCBmbGFnXTtcbn07XG52YXIgY29uc3VtZUlkZW50VW5zYWZlID0gZnVuY3Rpb24gY29uc3VtZUlkZW50VW5zYWZlKHN0ciwgaW5kZXgpIHtcbiAgaWYgKHN0ci5sZW5ndGggPD0gaW5kZXgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBpZGVudENoYXJzID0gW107XG5cbiAgZm9yICh2YXIgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGluZGV4KTsgaW5kZXggPCBzdHIubGVuZ3RoOyBjb2RlID0gc3RyLmNoYXJDb2RlQXQoKytpbmRleCkpIHtcbiAgICBpZiAoY29kZSA9PT0gMHgwMDJkIHx8IGNvZGUgPT09IDB4MDA1ZiB8fCBjb2RlID49IDB4MDA0MSAmJiBjb2RlIDw9IDB4MDA1YSB8fCBjb2RlID49IDB4MDA2MSAmJiBjb2RlIDw9IDB4MDA3YSB8fCBjb2RlID49IDB4MDA4MCB8fCBjb2RlID49IDB4MDAzMCAmJiBjb2RlIDw9IDB4MDAzOSkge1xuICAgICAgaWRlbnRDaGFycy5wdXNoKGNvZGUpO1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZXN1bHQgPSBjb25zdW1lRXNjYXBlKHN0ciwgaW5kZXgpO1xuXG4gICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBfYSA9IF9fcmVhZChyZXN1bHQsIDIpLFxuICAgICAgICAgICAgbGFzdEluZGV4ID0gX2FbMF0sXG4gICAgICAgICAgICBjb2RlXzQgPSBfYVsxXTtcblxuICAgICAgICBpZGVudENoYXJzLnB1c2goY29kZV80KTtcbiAgICAgICAgaW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIGluZGV4ID09PSAwID8gbnVsbCA6IFtpbmRleCAtIDEsIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgaWRlbnRDaGFycyldO1xufTtcbnZhciBjb25zdW1lSWRlbnQgPSBmdW5jdGlvbiBjb25zdW1lSWRlbnQoc3RyLCBpbmRleCkge1xuICBpZiAoc3RyLmxlbmd0aCA8PSBpbmRleCB8fCAhd291bGRTdGFydElkZW50aWZpZXIoc3RyLCBpbmRleCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBpZGVudENoYXJzID0gW107XG5cbiAgZm9yICh2YXIgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGluZGV4KTsgaW5kZXggPCBzdHIubGVuZ3RoOyBjb2RlID0gc3RyLmNoYXJDb2RlQXQoKytpbmRleCkpIHtcbiAgICBpZiAoY29kZSA9PT0gMHgwMDJkIHx8IGNvZGUgPT09IDB4MDA1ZiB8fCBjb2RlID49IDB4MDA0MSAmJiBjb2RlIDw9IDB4MDA1YSB8fCBjb2RlID49IDB4MDA2MSAmJiBjb2RlIDw9IDB4MDA3YSB8fCBjb2RlID49IDB4MDA4MCB8fCBjb2RlID49IDB4MDAzMCAmJiBjb2RlIDw9IDB4MDAzOSkge1xuICAgICAgaWRlbnRDaGFycy5wdXNoKGNvZGUpO1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZXN1bHQgPSBjb25zdW1lRXNjYXBlKHN0ciwgaW5kZXgpO1xuXG4gICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBfYSA9IF9fcmVhZChyZXN1bHQsIDIpLFxuICAgICAgICAgICAgbGFzdEluZGV4ID0gX2FbMF0sXG4gICAgICAgICAgICBjb2RlXzUgPSBfYVsxXTtcblxuICAgICAgICBpZGVudENoYXJzLnB1c2goY29kZV81KTtcbiAgICAgICAgaW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIFtpbmRleCAtIDEsIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgaWRlbnRDaGFycyldO1xufTtcbnZhciBjb25zdW1lVXJsID0gZnVuY3Rpb24gY29uc3VtZVVybChzdHIsIGluZGV4KSB7XG4gIHZhciBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXgpO1xuXG4gIHdoaWxlIChjb2RlID09PSAweDAwMDkgfHwgY29kZSA9PT0gMHgwMDIwIHx8IGNvZGUgPT09IDB4MDAwYSkge1xuICAgIGNvZGUgPSBzdHIuY2hhckNvZGVBdCgrK2luZGV4KTtcbiAgfVxuXG4gIHZhciB1cmxDaGFycyA9IFtdO1xuICB2YXIgaGFzRmluaXNoZWRXb3JkID0gZmFsc2U7XG5cbiAgd2hpbGUgKGluZGV4IDwgc3RyLmxlbmd0aCkge1xuICAgIGlmIChjb2RlID09PSAweDAwMjkpIHtcbiAgICAgIHJldHVybiBbaW5kZXgsIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgdXJsQ2hhcnMpXTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDAyMiB8fCBjb2RlID09PSAweDAwMjcgfHwgY29kZSA9PT0gMHgwMDI4KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDAwOSB8fCBjb2RlID09PSAweDAwMjAgfHwgY29kZSA9PT0gMHgwMDBhKSB7XG4gICAgICBpZiAoIWhhc0ZpbmlzaGVkV29yZCAmJiB1cmxDaGFycy5sZW5ndGggIT09IDApIGhhc0ZpbmlzaGVkV29yZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwNWMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBjb25zdW1lRXNjYXBlKHN0ciwgaW5kZXgpO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCBoYXNGaW5pc2hlZFdvcmQpIHJldHVybiBudWxsO1xuXG4gICAgICB2YXIgX2EgPSBfX3JlYWQocmVzdWx0LCAyKSxcbiAgICAgICAgICBsYXN0SW5kZXggPSBfYVswXSxcbiAgICAgICAgICB2YWx1ZSA9IF9hWzFdO1xuXG4gICAgICB1cmxDaGFycy5wdXNoKHZhbHVlKTtcbiAgICAgIGluZGV4ID0gbGFzdEluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaGFzRmluaXNoZWRXb3JkKSByZXR1cm4gbnVsbDtcbiAgICAgIHVybENoYXJzLnB1c2goY29kZSk7XG4gICAgfVxuXG4gICAgY29kZSA9IHN0ci5jaGFyQ29kZUF0KCsraW5kZXgpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xudmFyIGNvbnN1bWVJZGVudExpa2UgPSBmdW5jdGlvbiBjb25zdW1lSWRlbnRMaWtlKHN0ciwgaW5kZXgpIHtcbiAgdmFyIHJlc3VsdCA9IGNvbnN1bWVJZGVudChzdHIsIGluZGV4KTtcbiAgaWYgKHJlc3VsdCA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIF9hID0gX19yZWFkKHJlc3VsdCwgMiksXG4gICAgICBsYXN0SW5kZXggPSBfYVswXSxcbiAgICAgIHZhbHVlID0gX2FbMV07XG5cbiAgaWYgKHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09ICd1cmwnKSB7XG4gICAgaWYgKHN0ci5sZW5ndGggPiBsYXN0SW5kZXggKyAxKSB7XG4gICAgICB2YXIgbmV4dENvZGUgPSBzdHIuY2hhckNvZGVBdChsYXN0SW5kZXggKyAxKTtcblxuICAgICAgaWYgKG5leHRDb2RlID09PSAweDAwMjgpIHtcbiAgICAgICAgZm9yICh2YXIgb2Zmc2V0ID0gMjsgbGFzdEluZGV4ICsgb2Zmc2V0IDwgc3RyLmxlbmd0aDsgb2Zmc2V0ICs9IDEpIHtcbiAgICAgICAgICB2YXIgbmV4dE5leHRDb2RlID0gc3RyLmNoYXJDb2RlQXQobGFzdEluZGV4ICsgb2Zmc2V0KTtcblxuICAgICAgICAgIGlmIChuZXh0TmV4dENvZGUgPT09IDB4MDAyMiB8fCBuZXh0TmV4dENvZGUgPT09IDB4MDAyNykge1xuICAgICAgICAgICAgcmV0dXJuIFtsYXN0SW5kZXggKyAxLCB2YWx1ZS50b0xvd2VyQ2FzZSgpLCAnPGZ1bmN0aW9uLXRva2VuPiddO1xuICAgICAgICAgIH0gZWxzZSBpZiAobmV4dE5leHRDb2RlICE9PSAweDAwMDkgJiYgbmV4dE5leHRDb2RlICE9PSAweDAwMjAgJiYgbmV4dE5leHRDb2RlICE9PSAweDAwMGEpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRfMSA9IGNvbnN1bWVVcmwoc3RyLCBsYXN0SW5kZXggKyBvZmZzZXQpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdF8xID09PSBudWxsKSByZXR1cm4gbnVsbDtcblxuICAgICAgICAgICAgdmFyIF9iID0gX19yZWFkKHJlc3VsdF8xLCAyKSxcbiAgICAgICAgICAgICAgICBsYXN0VXJsSW5kZXggPSBfYlswXSxcbiAgICAgICAgICAgICAgICB2YWx1ZV8xID0gX2JbMV07XG5cbiAgICAgICAgICAgIHJldHVybiBbbGFzdFVybEluZGV4LCB2YWx1ZV8xLCAnPHVybC10b2tlbj4nXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW2xhc3RJbmRleCArIDEsIHZhbHVlLnRvTG93ZXJDYXNlKCksICc8ZnVuY3Rpb24tdG9rZW4+J107XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHN0ci5sZW5ndGggPiBsYXN0SW5kZXggKyAxKSB7XG4gICAgdmFyIG5leHRDb2RlID0gc3RyLmNoYXJDb2RlQXQobGFzdEluZGV4ICsgMSk7XG5cbiAgICBpZiAobmV4dENvZGUgPT09IDB4MDAyOCkge1xuICAgICAgcmV0dXJuIFtsYXN0SW5kZXggKyAxLCB2YWx1ZS50b0xvd2VyQ2FzZSgpLCAnPGZ1bmN0aW9uLXRva2VuPiddO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbbGFzdEluZGV4LCB2YWx1ZS50b0xvd2VyQ2FzZSgpLCAnPGlkZW50LXRva2VuPiddO1xufTtcblxudmFyIHNpbXBsaWZ5QVNUID0gZnVuY3Rpb24gc2ltcGxpZnlBU1QoYXN0KSB7XG4gIGZvciAodmFyIGkgPSBhc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBhc3RbaV0gPSBzaW1wbGlmeU1lZGlhUXVlcnkoYXN0W2ldKTtcbiAgfVxuXG4gIHJldHVybiBhc3Q7XG59O1xuXG52YXIgc2ltcGxpZnlNZWRpYVF1ZXJ5ID0gZnVuY3Rpb24gc2ltcGxpZnlNZWRpYVF1ZXJ5KG1lZGlhUXVlcnkpIHtcbiAgaWYgKG1lZGlhUXVlcnkubWVkaWFDb25kaXRpb24gPT09IG51bGwpIHJldHVybiBtZWRpYVF1ZXJ5O1xuICB2YXIgbWVkaWFDb25kaXRpb24gPSBzaW1wbGlmeU1lZGlhQ29uZGl0aW9uKG1lZGlhUXVlcnkubWVkaWFDb25kaXRpb24pO1xuXG4gIGlmIChtZWRpYUNvbmRpdGlvbi5vcGVyYXRvciA9PT0gbnVsbCAmJiBtZWRpYUNvbmRpdGlvbi5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgJ2NoaWxkcmVuJyBpbiBtZWRpYUNvbmRpdGlvbi5jaGlsZHJlblswXSkge1xuICAgIG1lZGlhQ29uZGl0aW9uID0gbWVkaWFDb25kaXRpb24uY2hpbGRyZW5bMF07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1lZGlhUHJlZml4OiBtZWRpYVF1ZXJ5Lm1lZGlhUHJlZml4LFxuICAgIG1lZGlhVHlwZTogbWVkaWFRdWVyeS5tZWRpYVR5cGUsXG4gICAgbWVkaWFDb25kaXRpb246IG1lZGlhQ29uZGl0aW9uXG4gIH07XG59O1xuXG52YXIgc2ltcGxpZnlNZWRpYUNvbmRpdGlvbiA9IGZ1bmN0aW9uIHNpbXBsaWZ5TWVkaWFDb25kaXRpb24obWVkaWFDb25kaXRpb24pIHtcbiAgZm9yICh2YXIgaSA9IG1lZGlhQ29uZGl0aW9uLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHVuc2ltcGxpZmllZENoaWxkID0gbWVkaWFDb25kaXRpb24uY2hpbGRyZW5baV07XG5cbiAgICBpZiAoISgnY29udGV4dCcgaW4gdW5zaW1wbGlmaWVkQ2hpbGQpKSB7XG4gICAgICB2YXIgY2hpbGQgPSBzaW1wbGlmeU1lZGlhQ29uZGl0aW9uKHVuc2ltcGxpZmllZENoaWxkKTtcblxuICAgICAgaWYgKGNoaWxkLm9wZXJhdG9yID09PSBudWxsICYmIGNoaWxkLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBtZWRpYUNvbmRpdGlvbi5jaGlsZHJlbltpXSA9IGNoaWxkLmNoaWxkcmVuWzBdO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZC5vcGVyYXRvciA9PT0gbWVkaWFDb25kaXRpb24ub3BlcmF0b3IgJiYgKGNoaWxkLm9wZXJhdG9yID09PSAnYW5kJyB8fCBjaGlsZC5vcGVyYXRvciA9PT0gJ29yJykpIHtcbiAgICAgICAgdmFyIHNwbGljZUFyZ3MgPSBbaSwgMV07XG5cbiAgICAgICAgZm9yICh2YXIgaV8xID0gMDsgaV8xIDwgY2hpbGQuY2hpbGRyZW4ubGVuZ3RoOyBpXzErKykge1xuICAgICAgICAgIHNwbGljZUFyZ3MucHVzaChjaGlsZC5jaGlsZHJlbltpXzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1lZGlhQ29uZGl0aW9uLmNoaWxkcmVuLnNwbGljZS5hcHBseShtZWRpYUNvbmRpdGlvbi5jaGlsZHJlbiwgc3BsaWNlQXJncyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1lZGlhQ29uZGl0aW9uO1xufTtcblxudmFyIGNyZWF0ZUVycm9yID0gZnVuY3Rpb24gY3JlYXRlRXJyb3IobWVzc2FnZSwgZXJyKSB7XG4gIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXCJcIi5jb25jYXQoZXJyLm1lc3NhZ2UudHJpbSgpLCBcIlxcblwiKS5jb25jYXQobWVzc2FnZS50cmltKCkpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKG1lc3NhZ2UudHJpbSgpKTtcbiAgfVxufTtcblxudmFyIHRvQVNUID0gZnVuY3Rpb24gdG9BU1Qoc3RyKSB7XG4gIHJldHVybiBzaW1wbGlmeUFTVCh0b1VuZmxhdHRlbmVkQVNUKHN0cikpO1xufTtcbnZhciB0b1VuZmxhdHRlbmVkQVNUID0gZnVuY3Rpb24gdG9VbmZsYXR0ZW5lZEFTVChzdHIpIHtcbiAgdmFyIHRva2VuTGlzdCA9IGxleGljYWxBbmFseXNpcyhzdHIudHJpbSgpKTtcblxuICBpZiAodG9rZW5MaXN0ID09PSBudWxsKSB7XG4gICAgdGhyb3cgY3JlYXRlRXJyb3IoJ0ZhaWxlZCB0b2tlbml6aW5nJyk7XG4gIH1cblxuICB2YXIgc3RhcnRJbmRleCA9IDA7XG4gIHZhciBlbmRJbmRleCA9IHRva2VuTGlzdC5sZW5ndGggLSAxO1xuXG4gIGlmICh0b2tlbkxpc3RbMF0udHlwZSA9PT0gJzxhdC1rZXl3b3JkLXRva2VuPicgJiYgdG9rZW5MaXN0WzBdLnZhbHVlID09PSAnbWVkaWEnKSB7XG4gICAgaWYgKHRva2VuTGlzdFsxXS50eXBlICE9PSAnPHdoaXRlc3BhY2UtdG9rZW4+Jykge1xuICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoJ0V4cGVjdGVkIHdoaXRlc3BhY2UgYWZ0ZXIgbWVkaWEnKTtcbiAgICB9XG5cbiAgICBzdGFydEluZGV4ID0gMjtcblxuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgdG9rZW5MaXN0Lmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgdmFyIHRva2VuID0gdG9rZW5MaXN0W2ldO1xuXG4gICAgICBpZiAodG9rZW4udHlwZSA9PT0gJzx7LXRva2VuPicpIHtcbiAgICAgICAgZW5kSW5kZXggPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gJzxzZW1pY29sb24tdG9rZW4+Jykge1xuICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcihcIkV4cGVjdGVkICd7JyBpbiBtZWRpYSBxdWVyeSBidXQgZm91bmQgJzsnXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRva2VuTGlzdCA9IHRva2VuTGlzdC5zbGljZShzdGFydEluZGV4LCBlbmRJbmRleCk7XG4gIHJldHVybiBzeW50YWN0aWNBbmFseXNpcyh0b2tlbkxpc3QpO1xufTtcbnZhciByZW1vdmVXaGl0ZXNwYWNlID0gZnVuY3Rpb24gcmVtb3ZlV2hpdGVzcGFjZSh0b2tlbkxpc3QpIHtcbiAgdmFyIG5ld1Rva2VuTGlzdCA9IFtdO1xuICB2YXIgYmVmb3JlID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbkxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodG9rZW5MaXN0W2ldLnR5cGUgPT09ICc8d2hpdGVzcGFjZS10b2tlbj4nKSB7XG4gICAgICBiZWZvcmUgPSB0cnVlO1xuXG4gICAgICBpZiAobmV3VG9rZW5MaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgbmV3VG9rZW5MaXN0W25ld1Rva2VuTGlzdC5sZW5ndGggLSAxXS53c0FmdGVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbmV3VG9rZW5MaXN0LnB1c2goX19hc3NpZ24oX19hc3NpZ24oe30sIHRva2VuTGlzdFtpXSksIHtcbiAgICAgICAgd3NCZWZvcmU6IGJlZm9yZSxcbiAgICAgICAgd3NBZnRlcjogZmFsc2VcbiAgICAgIH0pKTtcbiAgICAgIGJlZm9yZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdUb2tlbkxpc3Q7XG59O1xudmFyIHN5bnRhY3RpY0FuYWx5c2lzID0gZnVuY3Rpb24gc3ludGFjdGljQW5hbHlzaXModG9rZW5MaXN0KSB7XG4gIHZhciBlXzEsIF9hO1xuXG4gIHZhciBtZWRpYVF1ZXJ5TGlzdCA9IFtbXV07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbkxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdG9rZW4gPSB0b2tlbkxpc3RbaV07XG5cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJzxjb21tYS10b2tlbj4nKSB7XG4gICAgICBtZWRpYVF1ZXJ5TGlzdC5wdXNoKFtdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWVkaWFRdWVyeUxpc3RbbWVkaWFRdWVyeUxpc3QubGVuZ3RoIC0gMV0ucHVzaCh0b2tlbik7XG4gICAgfVxuICB9XG5cbiAgdmFyIG1lZGlhUXVlcmllcyA9IG1lZGlhUXVlcnlMaXN0Lm1hcChyZW1vdmVXaGl0ZXNwYWNlKTtcblxuICBpZiAobWVkaWFRdWVyaWVzLmxlbmd0aCA9PT0gMSAmJiBtZWRpYVF1ZXJpZXNbMF0ubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFt7XG4gICAgICBtZWRpYUNvbmRpdGlvbjogbnVsbCxcbiAgICAgIG1lZGlhUHJlZml4OiBudWxsLFxuICAgICAgbWVkaWFUeXBlOiAnYWxsJ1xuICAgIH1dO1xuICB9IGVsc2Uge1xuICAgIHZhciBtZWRpYVF1ZXJ5VG9rZW5zID0gbWVkaWFRdWVyaWVzLm1hcChmdW5jdGlvbiAobWVkaWFRdWVyeVRva2Vucykge1xuICAgICAgaWYgKG1lZGlhUXVlcnlUb2tlbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRva2VuaXplTWVkaWFRdWVyeShtZWRpYVF1ZXJ5VG9rZW5zKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgbm9uTnVsbE1lZGlhUXVlcnlUb2tlbnMgPSBbXTtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKHZhciBtZWRpYVF1ZXJ5VG9rZW5zXzEgPSBfX3ZhbHVlcyhtZWRpYVF1ZXJ5VG9rZW5zKSwgbWVkaWFRdWVyeVRva2Vuc18xXzEgPSBtZWRpYVF1ZXJ5VG9rZW5zXzEubmV4dCgpOyAhbWVkaWFRdWVyeVRva2Vuc18xXzEuZG9uZTsgbWVkaWFRdWVyeVRva2Vuc18xXzEgPSBtZWRpYVF1ZXJ5VG9rZW5zXzEubmV4dCgpKSB7XG4gICAgICAgIHZhciBtZWRpYVF1ZXJ5VG9rZW4gPSBtZWRpYVF1ZXJ5VG9rZW5zXzFfMS52YWx1ZTtcblxuICAgICAgICBpZiAobWVkaWFRdWVyeVRva2VuICE9PSBudWxsKSB7XG4gICAgICAgICAgbm9uTnVsbE1lZGlhUXVlcnlUb2tlbnMucHVzaChtZWRpYVF1ZXJ5VG9rZW4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZV8xXzEpIHtcbiAgICAgIGVfMSA9IHtcbiAgICAgICAgZXJyb3I6IGVfMV8xXG4gICAgICB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAobWVkaWFRdWVyeVRva2Vuc18xXzEgJiYgIW1lZGlhUXVlcnlUb2tlbnNfMV8xLmRvbmUgJiYgKF9hID0gbWVkaWFRdWVyeVRva2Vuc18xW1wicmV0dXJuXCJdKSkgX2EuY2FsbChtZWRpYVF1ZXJ5VG9rZW5zXzEpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChub25OdWxsTWVkaWFRdWVyeVRva2Vucy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IGNyZWF0ZUVycm9yKCdObyB2YWxpZCBtZWRpYSBxdWVyaWVzJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vbk51bGxNZWRpYVF1ZXJ5VG9rZW5zO1xuICB9XG59O1xudmFyIHRva2VuaXplTWVkaWFRdWVyeSA9IGZ1bmN0aW9uIHRva2VuaXplTWVkaWFRdWVyeSh0b2tlbnMpIHtcbiAgdmFyIGZpcnN0VG9rZW4gPSB0b2tlbnNbMF07XG5cbiAgaWYgKGZpcnN0VG9rZW4udHlwZSA9PT0gJzwoLXRva2VuPicpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWVkaWFQcmVmaXg6IG51bGwsXG4gICAgICAgIG1lZGlhVHlwZTogJ2FsbCcsXG4gICAgICAgIG1lZGlhQ29uZGl0aW9uOiB0b2tlbml6ZU1lZGlhQ29uZGl0aW9uKHRva2VucywgdHJ1ZSlcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBjcmVhdGVFcnJvcihcIkV4cGVjdGVkIG1lZGlhIGNvbmRpdGlvbiBhZnRlciAnKCdcIiwgZXJyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZmlyc3RUb2tlbi50eXBlID09PSAnPGlkZW50LXRva2VuPicpIHtcbiAgICB2YXIgbWVkaWFQcmVmaXggPSBudWxsO1xuICAgIHZhciBtZWRpYVR5cGUgPSB2b2lkIDA7XG4gICAgdmFyIHZhbHVlID0gZmlyc3RUb2tlbi52YWx1ZTtcblxuICAgIGlmICh2YWx1ZSA9PT0gJ29ubHknIHx8IHZhbHVlID09PSAnbm90Jykge1xuICAgICAgbWVkaWFQcmVmaXggPSB2YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgZmlyc3RJbmRleCA9IG1lZGlhUHJlZml4ID09PSBudWxsID8gMCA6IDE7XG5cbiAgICBpZiAodG9rZW5zLmxlbmd0aCA8PSBmaXJzdEluZGV4KSB7XG4gICAgICB0aHJvdyBjcmVhdGVFcnJvcihcIkV4cGVjdGVkIGV4dHJhIHRva2VuIGluIG1lZGlhIHF1ZXJ5XCIpO1xuICAgIH1cblxuICAgIHZhciBmaXJzdE5vblVuYXJ5VG9rZW4gPSB0b2tlbnNbZmlyc3RJbmRleF07XG5cbiAgICBpZiAoZmlyc3ROb25VbmFyeVRva2VuLnR5cGUgPT09ICc8aWRlbnQtdG9rZW4+Jykge1xuICAgICAgdmFyIHZhbHVlXzEgPSBmaXJzdE5vblVuYXJ5VG9rZW4udmFsdWU7XG5cbiAgICAgIGlmICh2YWx1ZV8xID09PSAnYWxsJykge1xuICAgICAgICBtZWRpYVR5cGUgPSAnYWxsJztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWVfMSA9PT0gJ3ByaW50JyB8fCB2YWx1ZV8xID09PSAnc2NyZWVuJykge1xuICAgICAgICBtZWRpYVR5cGUgPSB2YWx1ZV8xO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZV8xID09PSAndHR5JyB8fCB2YWx1ZV8xID09PSAndHYnIHx8IHZhbHVlXzEgPT09ICdwcm9qZWN0aW9uJyB8fCB2YWx1ZV8xID09PSAnaGFuZGhlbGQnIHx8IHZhbHVlXzEgPT09ICdicmFpbGxlJyB8fCB2YWx1ZV8xID09PSAnZW1ib3NzZWQnIHx8IHZhbHVlXzEgPT09ICdhdXJhbCcgfHwgdmFsdWVfMSA9PT0gJ3NwZWVjaCcpIHtcbiAgICAgICAgbWVkaWFQcmVmaXggPSBtZWRpYVByZWZpeCA9PT0gJ25vdCcgPyBudWxsIDogJ25vdCc7XG4gICAgICAgIG1lZGlhVHlwZSA9ICdhbGwnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoXCJVbmtub3duIGlkZW50ICdcIi5jb25jYXQodmFsdWVfMSwgXCInIGluIG1lZGlhIHF1ZXJ5XCIpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1lZGlhUHJlZml4ID09PSAnbm90JyAmJiBmaXJzdE5vblVuYXJ5VG9rZW4udHlwZSA9PT0gJzwoLXRva2VuPicpIHtcbiAgICAgIHZhciB0b2tlbnNXaXRoUGFyZW5zID0gW3tcbiAgICAgICAgdHlwZTogJzwoLXRva2VuPicsXG4gICAgICAgIHdzQmVmb3JlOiBmYWxzZSxcbiAgICAgICAgd3NBZnRlcjogZmFsc2VcbiAgICAgIH1dO1xuICAgICAgdG9rZW5zV2l0aFBhcmVucy5wdXNoLmFwcGx5KHRva2Vuc1dpdGhQYXJlbnMsIHRva2Vucyk7XG4gICAgICB0b2tlbnNXaXRoUGFyZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnPCktdG9rZW4+JyxcbiAgICAgICAgd3NCZWZvcmU6IGZhbHNlLFxuICAgICAgICB3c0FmdGVyOiBmYWxzZVxuICAgICAgfSk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWVkaWFQcmVmaXg6IG51bGwsXG4gICAgICAgICAgbWVkaWFUeXBlOiAnYWxsJyxcbiAgICAgICAgICBtZWRpYUNvbmRpdGlvbjogdG9rZW5pemVNZWRpYUNvbmRpdGlvbih0b2tlbnNXaXRoUGFyZW5zLCB0cnVlKVxuICAgICAgICB9O1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUVycm9yKFwiRXhwZWN0ZWQgbWVkaWEgY29uZGl0aW9uIGFmdGVyICcoJ1wiLCBlcnIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBjcmVhdGVFcnJvcignSW52YWxpZCBtZWRpYSBxdWVyeScpO1xuICAgIH1cblxuICAgIGlmIChmaXJzdEluZGV4ICsgMSA9PT0gdG9rZW5zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWVkaWFQcmVmaXg6IG1lZGlhUHJlZml4LFxuICAgICAgICBtZWRpYVR5cGU6IG1lZGlhVHlwZSxcbiAgICAgICAgbWVkaWFDb25kaXRpb246IG51bGxcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChmaXJzdEluZGV4ICsgNCA8IHRva2Vucy5sZW5ndGgpIHtcbiAgICAgIHZhciBzZWNvbmROb25VbmFyeVRva2VuID0gdG9rZW5zW2ZpcnN0SW5kZXggKyAxXTtcblxuICAgICAgaWYgKHNlY29uZE5vblVuYXJ5VG9rZW4udHlwZSA9PT0gJzxpZGVudC10b2tlbj4nICYmIHNlY29uZE5vblVuYXJ5VG9rZW4udmFsdWUgPT09ICdhbmQnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lZGlhUHJlZml4OiBtZWRpYVByZWZpeCxcbiAgICAgICAgICAgIG1lZGlhVHlwZTogbWVkaWFUeXBlLFxuICAgICAgICAgICAgbWVkaWFDb25kaXRpb246IHRva2VuaXplTWVkaWFDb25kaXRpb24odG9rZW5zLnNsaWNlKGZpcnN0SW5kZXggKyAyKSwgZmFsc2UpXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoXCJFeHBlY3RlZCBtZWRpYSBjb25kaXRpb24gYWZ0ZXIgJ2FuZCdcIiwgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoXCJFeHBlY3RlZCAnYW5kJyBhZnRlciBtZWRpYSBwcmVmaXhcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGNyZWF0ZUVycm9yKCdFeHBlY3RlZCBtZWRpYSBjb25kaXRpb24gYWZ0ZXIgbWVkaWEgcHJlZml4Jyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IGNyZWF0ZUVycm9yKCdFeHBlY3RlZCBtZWRpYSBjb25kaXRpb24gb3IgbWVkaWEgcHJlZml4Jyk7XG4gIH1cbn07XG52YXIgdG9rZW5pemVNZWRpYUNvbmRpdGlvbiA9IGZ1bmN0aW9uIHRva2VuaXplTWVkaWFDb25kaXRpb24odG9rZW5zLCBtYXlDb250YWluT3IsIHByZXZpb3VzT3BlcmF0b3IpIHtcbiAgaWYgKHByZXZpb3VzT3BlcmF0b3IgPT09IHZvaWQgMCkge1xuICAgIHByZXZpb3VzT3BlcmF0b3IgPSBudWxsO1xuICB9XG5cbiAgaWYgKHRva2Vucy5sZW5ndGggPCAzIHx8IHRva2Vuc1swXS50eXBlICE9PSAnPCgtdG9rZW4+JyB8fCB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLnR5cGUgIT09ICc8KS10b2tlbj4nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1lZGlhIGNvbmRpdGlvbicpO1xuICB9XG5cbiAgdmFyIGVuZEluZGV4T2ZGaXJzdEZlYXR1cmUgPSB0b2tlbnMubGVuZ3RoIC0gMTtcbiAgdmFyIG1heERlcHRoID0gMDtcbiAgdmFyIGNvdW50ID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgIGlmICh0b2tlbi50eXBlID09PSAnPCgtdG9rZW4+Jykge1xuICAgICAgY291bnQgKz0gMTtcbiAgICAgIG1heERlcHRoID0gTWF0aC5tYXgobWF4RGVwdGgsIGNvdW50KTtcbiAgICB9IGVsc2UgaWYgKHRva2VuLnR5cGUgPT09ICc8KS10b2tlbj4nKSB7XG4gICAgICBjb3VudCAtPSAxO1xuICAgIH1cblxuICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgZW5kSW5kZXhPZkZpcnN0RmVhdHVyZSA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoY291bnQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc21hdGNoZWQgcGFyZW5zXFxuSW52YWxpZCBtZWRpYSBjb25kaXRpb24nKTtcbiAgfVxuXG4gIHZhciBjaGlsZDtcbiAgdmFyIGZlYXR1cmVUb2tlbnMgPSB0b2tlbnMuc2xpY2UoMCwgZW5kSW5kZXhPZkZpcnN0RmVhdHVyZSArIDEpO1xuXG4gIGlmIChtYXhEZXB0aCA9PT0gMSkge1xuICAgIGNoaWxkID0gdG9rZW5pemVNZWRpYUZlYXR1cmUoZmVhdHVyZVRva2Vucyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGZlYXR1cmVUb2tlbnNbMV0udHlwZSA9PT0gJzxpZGVudC10b2tlbj4nICYmIGZlYXR1cmVUb2tlbnNbMV0udmFsdWUgPT09ICdub3QnKSB7XG4gICAgICBjaGlsZCA9IHRva2VuaXplTWVkaWFDb25kaXRpb24oZmVhdHVyZVRva2Vucy5zbGljZSgyLCAtMSksIHRydWUsICdub3QnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hpbGQgPSB0b2tlbml6ZU1lZGlhQ29uZGl0aW9uKGZlYXR1cmVUb2tlbnMuc2xpY2UoMSwgLTEpLCB0cnVlKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZW5kSW5kZXhPZkZpcnN0RmVhdHVyZSA9PT0gdG9rZW5zLmxlbmd0aCAtIDEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb3BlcmF0b3I6IHByZXZpb3VzT3BlcmF0b3IsXG4gICAgICBjaGlsZHJlbjogW2NoaWxkXVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5leHRUb2tlbiA9IHRva2Vuc1tlbmRJbmRleE9mRmlyc3RGZWF0dXJlICsgMV07XG5cbiAgICBpZiAobmV4dFRva2VuLnR5cGUgIT09ICc8aWRlbnQtdG9rZW4+Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG9wZXJhdG9yXFxuSW52YWxpZCBtZWRpYSBjb25kaXRpb24nKTtcbiAgICB9IGVsc2UgaWYgKHByZXZpb3VzT3BlcmF0b3IgIT09IG51bGwgJiYgcHJldmlvdXNPcGVyYXRvciAhPT0gbmV4dFRva2VuLnZhbHVlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCInXCIuY29uY2F0KG5leHRUb2tlbi52YWx1ZSwgXCInIGFuZCAnXCIpLmNvbmNhdChwcmV2aW91c09wZXJhdG9yLCBcIicgbXVzdCBub3QgYmUgYXQgc2FtZSBsZXZlbFxcbkludmFsaWQgbWVkaWEgY29uZGl0aW9uXCIpKTtcbiAgICB9IGVsc2UgaWYgKG5leHRUb2tlbi52YWx1ZSA9PT0gJ29yJyAmJiAhbWF5Q29udGFpbk9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdXNlICdvcicgYXQgdG9wIGxldmVsIG9mIGEgbWVkaWEgcXVlcnlcXG5JbnZhbGlkIG1lZGlhIGNvbmRpdGlvblwiKTtcbiAgICB9IGVsc2UgaWYgKG5leHRUb2tlbi52YWx1ZSAhPT0gJ2FuZCcgJiYgbmV4dFRva2VuLnZhbHVlICE9PSAnb3InKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG9wZXJhdG9yOiAnXCIuY29uY2F0KG5leHRUb2tlbi52YWx1ZSwgXCInXFxuSW52YWxpZCBtZWRpYSBjb25kaXRpb25cIikpO1xuICAgIH1cblxuICAgIHZhciBzaWJsaW5ncyA9IHRva2VuaXplTWVkaWFDb25kaXRpb24odG9rZW5zLnNsaWNlKGVuZEluZGV4T2ZGaXJzdEZlYXR1cmUgKyAyKSwgbWF5Q29udGFpbk9yLCBuZXh0VG9rZW4udmFsdWUpO1xuICAgIHJldHVybiB7XG4gICAgICBvcGVyYXRvcjogbmV4dFRva2VuLnZhbHVlLFxuICAgICAgY2hpbGRyZW46IFtjaGlsZF0uY29uY2F0KHNpYmxpbmdzLmNoaWxkcmVuKVxuICAgIH07XG4gIH1cbn07XG52YXIgdG9rZW5pemVNZWRpYUZlYXR1cmUgPSBmdW5jdGlvbiB0b2tlbml6ZU1lZGlhRmVhdHVyZShyYXdUb2tlbnMpIHtcbiAgaWYgKHJhd1Rva2Vucy5sZW5ndGggPCAzIHx8IHJhd1Rva2Vuc1swXS50eXBlICE9PSAnPCgtdG9rZW4+JyB8fCByYXdUb2tlbnNbcmF3VG9rZW5zLmxlbmd0aCAtIDFdLnR5cGUgIT09ICc8KS10b2tlbj4nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1lZGlhIGZlYXR1cmUnKTtcbiAgfVxuXG4gIHZhciB0b2tlbnMgPSBbcmF3VG9rZW5zWzBdXTtcblxuICBmb3IgKHZhciBpID0gMTsgaSA8IHJhd1Rva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpIDwgcmF3VG9rZW5zLmxlbmd0aCAtIDIpIHtcbiAgICAgIHZhciBhID0gcmF3VG9rZW5zW2ldO1xuICAgICAgdmFyIGIgPSByYXdUb2tlbnNbaSArIDFdO1xuICAgICAgdmFyIGMgPSByYXdUb2tlbnNbaSArIDJdO1xuXG4gICAgICBpZiAoYS50eXBlID09PSAnPG51bWJlci10b2tlbj4nICYmIGEudmFsdWUgPiAwICYmIGIudHlwZSA9PT0gJzxkZWxpbS10b2tlbj4nICYmIGIudmFsdWUgPT09IDB4MDAyZiAmJiBjLnR5cGUgPT09ICc8bnVtYmVyLXRva2VuPicgJiYgYy52YWx1ZSA+IDApIHtcbiAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgIHR5cGU6ICc8cmF0aW8tdG9rZW4+JyxcbiAgICAgICAgICBudW1lcmF0b3I6IGEudmFsdWUsXG4gICAgICAgICAgZGVub21pbmF0b3I6IGMudmFsdWUsXG4gICAgICAgICAgd3NCZWZvcmU6IGEud3NCZWZvcmUsXG4gICAgICAgICAgd3NBZnRlcjogYy53c0FmdGVyXG4gICAgICAgIH0pO1xuICAgICAgICBpICs9IDI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRva2Vucy5wdXNoKHJhd1Rva2Vuc1tpXSk7XG4gIH1cblxuICB2YXIgbmV4dFRva2VuID0gdG9rZW5zWzFdO1xuXG4gIGlmIChuZXh0VG9rZW4udHlwZSA9PT0gJzxpZGVudC10b2tlbj4nICYmIHRva2Vucy5sZW5ndGggPT09IDMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29udGV4dDogJ2Jvb2xlYW4nLFxuICAgICAgZmVhdHVyZTogbmV4dFRva2VuLnZhbHVlXG4gICAgfTtcbiAgfSBlbHNlIGlmICh0b2tlbnMubGVuZ3RoID09PSA1ICYmIHRva2Vuc1sxXS50eXBlID09PSAnPGlkZW50LXRva2VuPicgJiYgdG9rZW5zWzJdLnR5cGUgPT09ICc8Y29sb24tdG9rZW4+Jykge1xuICAgIHZhciB2YWx1ZVRva2VuID0gdG9rZW5zWzNdO1xuXG4gICAgaWYgKHZhbHVlVG9rZW4udHlwZSA9PT0gJzxudW1iZXItdG9rZW4+JyB8fCB2YWx1ZVRva2VuLnR5cGUgPT09ICc8ZGltZW5zaW9uLXRva2VuPicgfHwgdmFsdWVUb2tlbi50eXBlID09PSAnPHJhdGlvLXRva2VuPicgfHwgdmFsdWVUb2tlbi50eXBlID09PSAnPGlkZW50LXRva2VuPicpIHtcbiAgICAgIHZhciBmZWF0dXJlID0gdG9rZW5zWzFdLnZhbHVlO1xuICAgICAgdmFyIHByZWZpeCA9IG51bGw7XG4gICAgICB2YXIgc2xpY2UgPSBmZWF0dXJlLnNsaWNlKDAsIDQpO1xuXG4gICAgICBpZiAoc2xpY2UgPT09ICdtaW4tJykge1xuICAgICAgICBwcmVmaXggPSAnbWluJztcbiAgICAgICAgZmVhdHVyZSA9IGZlYXR1cmUuc2xpY2UoNCk7XG4gICAgICB9IGVsc2UgaWYgKHNsaWNlID09PSAnbWF4LScpIHtcbiAgICAgICAgcHJlZml4ID0gJ21heCc7XG4gICAgICAgIGZlYXR1cmUgPSBmZWF0dXJlLnNsaWNlKDQpO1xuICAgICAgfVxuXG4gICAgICB2YWx1ZVRva2VuLndzQmVmb3JlO1xuICAgICAgICAgIHZhbHVlVG9rZW4ud3NBZnRlcjtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBfX3Jlc3QodmFsdWVUb2tlbiwgW1wid3NCZWZvcmVcIiwgXCJ3c0FmdGVyXCJdKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29udGV4dDogJ3ZhbHVlJyxcbiAgICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICAgIGZlYXR1cmU6IGZlYXR1cmUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodG9rZW5zLmxlbmd0aCA+PSA1KSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciByYW5nZSA9IHRva2VuaXplUmFuZ2UodG9rZW5zKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRleHQ6ICdyYW5nZScsXG4gICAgICAgIGZlYXR1cmU6IHJhbmdlLmZlYXR1cmVOYW1lLFxuICAgICAgICByYW5nZTogcmFuZ2VcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBjcmVhdGVFcnJvcignSW52YWxpZCBtZWRpYSBmZWF0dXJlJywgZXJyKTtcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWVkaWEgZmVhdHVyZScpO1xufTtcbnZhciB0b2tlbml6ZVJhbmdlID0gZnVuY3Rpb24gdG9rZW5pemVSYW5nZSh0b2tlbnMpIHtcbiAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuXG4gIGlmICh0b2tlbnMubGVuZ3RoIDwgNSB8fCB0b2tlbnNbMF0udHlwZSAhPT0gJzwoLXRva2VuPicgfHwgdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXS50eXBlICE9PSAnPCktdG9rZW4+Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByYW5nZScpO1xuICB9XG5cbiAgdmFyIHJhbmdlID0ge1xuICAgIGxlZnRUb2tlbjogbnVsbCxcbiAgICBsZWZ0T3A6IG51bGwsXG4gICAgZmVhdHVyZU5hbWU6ICcnLFxuICAgIHJpZ2h0T3A6IG51bGwsXG4gICAgcmlnaHRUb2tlbjogbnVsbFxuICB9O1xuICB2YXIgaGFzTGVmdCA9IHRva2Vuc1sxXS50eXBlID09PSAnPG51bWJlci10b2tlbj4nIHx8IHRva2Vuc1sxXS50eXBlID09PSAnPGRpbWVuc2lvbi10b2tlbj4nIHx8IHRva2Vuc1sxXS50eXBlID09PSAnPHJhdGlvLXRva2VuPicgfHwgdG9rZW5zWzFdLnR5cGUgPT09ICc8aWRlbnQtdG9rZW4+JyAmJiB0b2tlbnNbMV0udmFsdWUgPT09ICdpbmZpbml0ZSc7XG5cbiAgaWYgKHRva2Vuc1syXS50eXBlID09PSAnPGRlbGltLXRva2VuPicpIHtcbiAgICBpZiAodG9rZW5zWzJdLnZhbHVlID09PSAweDAwM2MpIHtcbiAgICAgIGlmICh0b2tlbnNbM10udHlwZSA9PT0gJzxkZWxpbS10b2tlbj4nICYmIHRva2Vuc1szXS52YWx1ZSA9PT0gMHgwMDNkICYmICF0b2tlbnNbM10ud3NCZWZvcmUpIHtcbiAgICAgICAgcmFuZ2VbaGFzTGVmdCA/ICdsZWZ0T3AnIDogJ3JpZ2h0T3AnXSA9ICc8PSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYW5nZVtoYXNMZWZ0ID8gJ2xlZnRPcCcgOiAncmlnaHRPcCddID0gJzwnO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodG9rZW5zWzJdLnZhbHVlID09PSAweDAwM2UpIHtcbiAgICAgIGlmICh0b2tlbnNbM10udHlwZSA9PT0gJzxkZWxpbS10b2tlbj4nICYmIHRva2Vuc1szXS52YWx1ZSA9PT0gMHgwMDNkICYmICF0b2tlbnNbM10ud3NCZWZvcmUpIHtcbiAgICAgICAgcmFuZ2VbaGFzTGVmdCA/ICdsZWZ0T3AnIDogJ3JpZ2h0T3AnXSA9ICc+PSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYW5nZVtoYXNMZWZ0ID8gJ2xlZnRPcCcgOiAncmlnaHRPcCddID0gJz4nO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodG9rZW5zWzJdLnZhbHVlID09PSAweDAwM2QpIHtcbiAgICAgIHJhbmdlW2hhc0xlZnQgPyAnbGVmdE9wJyA6ICdyaWdodE9wJ10gPSAnPSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByYW5nZScpO1xuICAgIH1cblxuICAgIGlmIChoYXNMZWZ0KSB7XG4gICAgICByYW5nZS5sZWZ0VG9rZW4gPSB0b2tlbnNbMV07XG4gICAgfSBlbHNlIGlmICh0b2tlbnNbMV0udHlwZSA9PT0gJzxpZGVudC10b2tlbj4nKSB7XG4gICAgICByYW5nZS5mZWF0dXJlTmFtZSA9IHRva2Vuc1sxXS52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJhbmdlJyk7XG4gICAgfVxuXG4gICAgdmFyIHRva2VuSW5kZXhBZnRlckZpcnN0T3AgPSAyICsgKChfYiA9IChfYSA9IHJhbmdlW2hhc0xlZnQgPyAnbGVmdE9wJyA6ICdyaWdodE9wJ10pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDApO1xuICAgIHZhciB0b2tlbkFmdGVyRmlyc3RPcCA9IHRva2Vuc1t0b2tlbkluZGV4QWZ0ZXJGaXJzdE9wXTtcblxuICAgIGlmIChoYXNMZWZ0KSB7XG4gICAgICBpZiAodG9rZW5BZnRlckZpcnN0T3AudHlwZSA9PT0gJzxpZGVudC10b2tlbj4nKSB7XG4gICAgICAgIHJhbmdlLmZlYXR1cmVOYW1lID0gdG9rZW5BZnRlckZpcnN0T3AudmFsdWU7XG5cbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPj0gNykge1xuICAgICAgICAgIHZhciBzZWNvbmRPcFRva2VuID0gdG9rZW5zW3Rva2VuSW5kZXhBZnRlckZpcnN0T3AgKyAxXTtcbiAgICAgICAgICB2YXIgZm9sbG93aW5nVG9rZW4gPSB0b2tlbnNbdG9rZW5JbmRleEFmdGVyRmlyc3RPcCArIDJdO1xuXG4gICAgICAgICAgaWYgKHNlY29uZE9wVG9rZW4udHlwZSA9PT0gJzxkZWxpbS10b2tlbj4nKSB7XG4gICAgICAgICAgICB2YXIgY2hhckNvZGUgPSBzZWNvbmRPcFRva2VuLnZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoY2hhckNvZGUgPT09IDB4MDAzYykge1xuICAgICAgICAgICAgICBpZiAoZm9sbG93aW5nVG9rZW4udHlwZSA9PT0gJzxkZWxpbS10b2tlbj4nICYmIGZvbGxvd2luZ1Rva2VuLnZhbHVlID09PSAweDAwM2QgJiYgIWZvbGxvd2luZ1Rva2VuLndzQmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2UucmlnaHRPcCA9ICc8PSc7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmFuZ2UucmlnaHRPcCA9ICc8JztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZSA9PT0gMHgwMDNlKSB7XG4gICAgICAgICAgICAgIGlmIChmb2xsb3dpbmdUb2tlbi50eXBlID09PSAnPGRlbGltLXRva2VuPicgJiYgZm9sbG93aW5nVG9rZW4udmFsdWUgPT09IDB4MDAzZCAmJiAhZm9sbG93aW5nVG9rZW4ud3NCZWZvcmUpIHtcbiAgICAgICAgICAgICAgICByYW5nZS5yaWdodE9wID0gJz49JztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByYW5nZS5yaWdodE9wID0gJz4nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmFuZ2UnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRva2VuQWZ0ZXJTZWNvbmRPcCA9IHRva2Vuc1t0b2tlbkluZGV4QWZ0ZXJGaXJzdE9wICsgMSArICgoX2QgPSAoX2MgPSByYW5nZS5yaWdodE9wKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubGVuZ3RoKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAwKV07XG4gICAgICAgICAgICByYW5nZS5yaWdodFRva2VuID0gdG9rZW5BZnRlclNlY29uZE9wO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmFuZ2UnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodG9rZW5JbmRleEFmdGVyRmlyc3RPcCArIDIgIT09IHRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJhbmdlJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlLnJpZ2h0VG9rZW4gPSB0b2tlbkFmdGVyRmlyc3RPcDtcbiAgICB9XG5cbiAgICB2YXIgdmFsaWRSYW5nZSA9IG51bGw7XG4gICAgdmFyIGx0ID0gcmFuZ2UubGVmdFRva2VuLFxuICAgICAgICBsZWZ0T3AgPSByYW5nZS5sZWZ0T3AsXG4gICAgICAgIGZlYXR1cmVOYW1lID0gcmFuZ2UuZmVhdHVyZU5hbWUsXG4gICAgICAgIHJpZ2h0T3AgPSByYW5nZS5yaWdodE9wLFxuICAgICAgICBydCA9IHJhbmdlLnJpZ2h0VG9rZW47XG4gICAgdmFyIGxlZnRUb2tlbiA9IG51bGw7XG5cbiAgICBpZiAobHQgIT09IG51bGwpIHtcbiAgICAgIGlmIChsdC50eXBlID09PSAnPGlkZW50LXRva2VuPicpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBsdC50eXBlLFxuICAgICAgICAgICAgdmFsdWUgPSBsdC52YWx1ZTtcblxuICAgICAgICBpZiAodmFsdWUgPT09ICdpbmZpbml0ZScpIHtcbiAgICAgICAgICBsZWZ0VG9rZW4gPSB7XG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChsdC50eXBlID09PSAnPG51bWJlci10b2tlbj4nIHx8IGx0LnR5cGUgPT09ICc8ZGltZW5zaW9uLXRva2VuPicgfHwgbHQudHlwZSA9PT0gJzxyYXRpby10b2tlbj4nKSB7XG4gICAgICAgIGx0LndzQmVmb3JlO1xuICAgICAgICAgICAgbHQud3NBZnRlcjtcbiAgICAgICAgICAgIHZhciBsdE5vV1MgPSBfX3Jlc3QobHQsIFtcIndzQmVmb3JlXCIsIFwid3NBZnRlclwiXSk7XG5cbiAgICAgICAgbGVmdFRva2VuID0gbHROb1dTO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByaWdodFRva2VuID0gbnVsbDtcblxuICAgIGlmIChydCAhPT0gbnVsbCkge1xuICAgICAgaWYgKHJ0LnR5cGUgPT09ICc8aWRlbnQtdG9rZW4+Jykge1xuICAgICAgICB2YXIgdHlwZSA9IHJ0LnR5cGUsXG4gICAgICAgICAgICB2YWx1ZSA9IHJ0LnZhbHVlO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJ2luZmluaXRlJykge1xuICAgICAgICAgIHJpZ2h0VG9rZW4gPSB7XG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChydC50eXBlID09PSAnPG51bWJlci10b2tlbj4nIHx8IHJ0LnR5cGUgPT09ICc8ZGltZW5zaW9uLXRva2VuPicgfHwgcnQudHlwZSA9PT0gJzxyYXRpby10b2tlbj4nKSB7XG4gICAgICAgIHJ0LndzQmVmb3JlO1xuICAgICAgICAgICAgcnQud3NBZnRlcjtcbiAgICAgICAgICAgIHZhciBydE5vV1MgPSBfX3Jlc3QocnQsIFtcIndzQmVmb3JlXCIsIFwid3NBZnRlclwiXSk7XG5cbiAgICAgICAgcmlnaHRUb2tlbiA9IHJ0Tm9XUztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobGVmdFRva2VuICE9PSBudWxsICYmIHJpZ2h0VG9rZW4gIT09IG51bGwpIHtcbiAgICAgIGlmICgobGVmdE9wID09PSAnPCcgfHwgbGVmdE9wID09PSAnPD0nKSAmJiAocmlnaHRPcCA9PT0gJzwnIHx8IHJpZ2h0T3AgPT09ICc8PScpKSB7XG4gICAgICAgIHZhbGlkUmFuZ2UgPSB7XG4gICAgICAgICAgbGVmdFRva2VuOiBsZWZ0VG9rZW4sXG4gICAgICAgICAgbGVmdE9wOiBsZWZ0T3AsXG4gICAgICAgICAgZmVhdHVyZU5hbWU6IGZlYXR1cmVOYW1lLFxuICAgICAgICAgIHJpZ2h0T3A6IHJpZ2h0T3AsXG4gICAgICAgICAgcmlnaHRUb2tlbjogcmlnaHRUb2tlblxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICgobGVmdE9wID09PSAnPicgfHwgbGVmdE9wID09PSAnPj0nKSAmJiAocmlnaHRPcCA9PT0gJz4nIHx8IHJpZ2h0T3AgPT09ICc+PScpKSB7XG4gICAgICAgIHZhbGlkUmFuZ2UgPSB7XG4gICAgICAgICAgbGVmdFRva2VuOiBsZWZ0VG9rZW4sXG4gICAgICAgICAgbGVmdE9wOiBsZWZ0T3AsXG4gICAgICAgICAgZmVhdHVyZU5hbWU6IGZlYXR1cmVOYW1lLFxuICAgICAgICAgIHJpZ2h0T3A6IHJpZ2h0T3AsXG4gICAgICAgICAgcmlnaHRUb2tlbjogcmlnaHRUb2tlblxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJhbmdlJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsZWZ0VG9rZW4gPT09IG51bGwgJiYgbGVmdE9wID09PSBudWxsICYmIHJpZ2h0T3AgIT09IG51bGwgJiYgcmlnaHRUb2tlbiAhPT0gbnVsbCkge1xuICAgICAgdmFsaWRSYW5nZSA9IHtcbiAgICAgICAgbGVmdFRva2VuOiBsZWZ0VG9rZW4sXG4gICAgICAgIGxlZnRPcDogbGVmdE9wLFxuICAgICAgICBmZWF0dXJlTmFtZTogZmVhdHVyZU5hbWUsXG4gICAgICAgIHJpZ2h0T3A6IHJpZ2h0T3AsXG4gICAgICAgIHJpZ2h0VG9rZW46IHJpZ2h0VG9rZW5cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChsZWZ0VG9rZW4gIT09IG51bGwgJiYgbGVmdE9wICE9PSBudWxsICYmIHJpZ2h0T3AgPT09IG51bGwgJiYgcmlnaHRUb2tlbiA9PT0gbnVsbCkge1xuICAgICAgdmFsaWRSYW5nZSA9IHtcbiAgICAgICAgbGVmdFRva2VuOiBsZWZ0VG9rZW4sXG4gICAgICAgIGxlZnRPcDogbGVmdE9wLFxuICAgICAgICBmZWF0dXJlTmFtZTogZmVhdHVyZU5hbWUsXG4gICAgICAgIHJpZ2h0T3A6IHJpZ2h0T3AsXG4gICAgICAgIHJpZ2h0VG9rZW46IHJpZ2h0VG9rZW5cbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbGlkUmFuZ2U7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJhbmdlJyk7XG4gIH1cbn07XG5cbmV4cG9ydCB7IGNvbnN1bWVFc2NhcGUsIGNvbnN1bWVJZGVudCwgY29uc3VtZUlkZW50TGlrZSwgY29uc3VtZUlkZW50VW5zYWZlLCBjb25zdW1lTnVtYmVyLCBjb25zdW1lTnVtZXJpYywgY29uc3VtZVN0cmluZywgY29uc3VtZVVybCwgbGV4aWNhbEFuYWx5c2lzLCByZW1vdmVXaGl0ZXNwYWNlLCBzeW50YWN0aWNBbmFseXNpcywgdG9BU1QsIHRvVW5mbGF0dGVuZWRBU1QsIHRva2VuaXplTWVkaWFDb25kaXRpb24sIHRva2VuaXplTWVkaWFGZWF0dXJlLCB0b2tlbml6ZU1lZGlhUXVlcnksIHRva2VuaXplUmFuZ2UsIHdvdWxkU3RhcnRJZGVudGlmaWVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZWRpYS1xdWVyeS1wYXJzZXIuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/media-query-parser/dist/media-query-parser.esm.js\n");

/***/ })

};
;